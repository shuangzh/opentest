package com.cmsz.cmup.fileImporting.validator.impl;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Component;

import com.cmsz.cmup.fileImporting.constant.FileHandleConstant;
import com.cmsz.cmup.fileImporting.validator.Field;
import com.cmsz.cmup.fileImporting.validator.FieldMatcher;
import com.cmsz.cmup.fileImporting.validator.Filter;
import com.cmsz.cmup.fileImporting.validator.Section;
import com.cmsz.cmup.fileImporting.validator.ValidateException;
import com.cmsz.cmup.fileImporting.validator.Validator;
import com.cmsz.cmup.fileImporting.validator.impl.fieldMatcher.DefaultFieldMatcherImpl;
import com.cmsz.cmup.fileImporting.validator.templateCfg.CaseCfg;
import com.cmsz.cmup.fileImporting.validator.templateCfg.ComponentCfg;
import com.cmsz.cmup.fileImporting.validator.templateCfg.FieldCfg;
import com.cmsz.cmup.fileImporting.validator.templateCfg.FilterCfg;
import com.cmsz.cmup.fileImporting.validator.templateCfg.RelaFieldCfg;
import com.cmsz.cmup.fileImporting.validator.templateCfg.Template;
import com.thoughtworks.xstream.XStream;

/**
 * 校验处理类
 * 
 * @author lenovo
 *
 */
@Component
public class ValidatorImpl implements Validator {

	private String regxFile;
	private FilterChainImpl chain;
	private List<Filter> filterList;
	private MinusRowNumChecker minusRowNumChecker;

	// 用于缓存从文件流中读取的每一行数据，用于批量写入一个中间文件。省BOSS文件专用。因要对行级错误做错误代码的插入。
	private List<String> lines = new ArrayList<String>();

	public String getRegxFile() {
		return regxFile;
	}

	public void setRegxFile(String regxFile) {
		this.regxFile = regxFile;
	}

	public void validate(InputStream inputStrem, Map<String, String> map) throws Exception {

		// 判断是否是行尾添加错误返回码类型的校验
		if (map.get(FileHandleConstant.DATA_ROW_ERROR_CODE).matches("^YES.*$")) {
			try {
				this.validateWithErrorCodeAdded(inputStrem, map);
				return;
			} catch (Exception e) {
				throw e;
			}
		}

		// 初始化异常信息类
		ValidateException ve = null;

		// 初始化模板
		initFilters(map);

		// 读入文件
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStrem));
		String line = null;
		int n = 0;
		// 循环读入文件内容，每次校验一行
		while ((line = reader.readLine()) != null) {
			try {
				// 行数计数
				n++;
				// 初始化处理行信息类
				Section section = new LineSection(n, line);
				// 开始匹配filter，校验文件
				chain.doFilter(section);
				minusRowNumChecker.makeCheckMaps(chain.getMatchedFilter(), section);
			} catch (ValidateException e) {
				// 出现异常，封装异常信息类
				if (ve == null) {
					ve = new ValidateException(null, ValidateException.CODE_FAILED, ValidateException.EMSG_FAILED);
				}
				ve.append(e);
			} catch (Exception exc) {
				if (!(exc instanceof ValidateException)) {
					reader.close();
					throw exc;
				}
			}
		}

		if (ve != null) {
			throw ve;
		}

		// 判断数据行数是否与文件头信息一致
		if (!"NULL".equals(map.get("lineCount"))) {
			int lineCount = Integer.parseInt(map.get("lineCount"));
			if (!(n == lineCount)) {
				ve = new ValidateException(null, ValidateException.CODE_DATASUM, ValidateException.EMSG_CODE_DATASUM);
				reader.close();
				ve.append(ve);
				throw ve;
			}
		}

		try {
			minusRowNumChecker.checkFilterRowMap();
		} catch (ValidateException e) {
			e.append(e);
			throw e;
		} finally {
			reader.close();
		}
	}

	/**
	 * 行尾添加错误返回码校验方法
	 * 
	 * @param inputStrem
	 * @param map
	 * @throws Exception
	 */
	public void validateWithErrorCodeAdded(InputStream inputStrem, Map<String, String> map) throws Exception {
		// 初始化异常信息类
		ValidateException ve = null;

		// 临时文件路径
		String localTempFilePath = map.get(FileHandleConstant.LOCAL_TEMP_FILE_PATH);
		File localTempFile = new File(localTempFilePath);
		// 清理异常残余文件
		if (localTempFile.exists()) {
			localTempFile.delete();
		}

		// 文件记录行添加错误返回码类型
		String type = map.get(FileHandleConstant.DATA_ROW_ERROR_CODE);

		// 初始化模板
		initFilters(map);

		// 读入文件
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStrem));
		String line = null;
		int n = 0;
		// 循环读入文件内容，每次校验一行
		while ((line = reader.readLine()) != null) {
			try {
				// 行数计数
				n++;
				// 初始化处理行信息类
				Section section = new LineSection(n, line);
				// 开始匹配filter，校验文件
				chain.doFilter(section);
				minusRowNumChecker.makeCheckMaps(chain.getMatchedFilter(), section);
			} catch (ValidateException e) {
				// 出现异常，封装异常信息类
				if (ve == null) {
					ve = new ValidateException(null, ValidateException.CODE_FAILED, ValidateException.EMSG_FAILED);
				}
				ve.append(e);

				// 往出错行里插入错误代码
				if (1 != n) {
					line = this.addErrorCode(line, e.getCode(), type);
				}
			} catch (Exception exc) {
				if (!(exc instanceof ValidateException)) {
					reader.close();
					throw exc;
				}
			}

			// 每读取一行数据，缓存到lines
			this.lines.add(line);
			// 当lines的总数等于1000的时候，写入临时文件。
			if (1000 == lines.size()) {
				this.copyToFile(localTempFilePath);
			}
		}

		// 最后再写入一次，避免不够1000行而没有写入的情况
		this.copyToFile(localTempFilePath);

		if (ve != null) {
			throw ve;
		}

		// 判断数据行数是否与文件头信息一致
		if (!"NULL".equals(map.get("lineCount"))) {
			int lineCount = Integer.parseInt(map.get("lineCount"));
			if (!(n == lineCount)) {
				ve = new ValidateException(null, ValidateException.CODE_DATASUM, ValidateException.EMSG_CODE_DATASUM);
				reader.close();
				ve.append(ve);
				throw ve;
			}
		}

		try {
			minusRowNumChecker.checkFilterRowMap();
		} catch (ValidateException e) {
			e.append(e);
			throw e;
		} finally {
			reader.close();
		}

		// 文件校验没有出错，删除临时工作文件副本
		File file = new File(localTempFilePath);
		if (file.exists()) {
			file.delete();
		}
	}

	/**
	 * 倒数行数要求的filter处理类
	 * 
	 * @author lenovo
	 *
	 */
	protected class MinusRowNumChecker {
		Map<Filter, Integer> filterRowMap = new HashMap<Filter, Integer>();
		Map<Filter, Section> filterSectionMap = new HashMap<Filter, Section>();

		/**
		 * 生成倒数行数要求的filter对应map
		 * 
		 * @param filter
		 * @param section
		 * @throws ValidateException
		 */
		public void makeCheckMaps(Filter filter, Section section) throws ValidateException {
			if (filter.getFixRowNum() < 0) {
				if (filterRowMap.containsKey(filter)) {
					throw new ValidateException(section, ValidateException.CODE_REPEATED,
							ValidateException.EMSG_REPEATED);
				} else {
					filterRowMap.put(filter, filter.getFixRowNum());
					filterSectionMap.put(filter, section);
				}
			}

			if (filterRowMap.size() > 0) {
				for (Filter f : filterRowMap.keySet()) {
					Integer r = filterRowMap.get(f);
					filterRowMap.put(f, ++r);
				}
			}
		}

		/**
		 * 检查filterRowMap是否每个value都为0
		 * 
		 * @throws ValidateException
		 */
		public void checkFilterRowMap() throws ValidateException {
			for (Filter f : filterRowMap.keySet()) {
				Integer r = filterRowMap.get(f);
				if (!(r == 0)) {
					throw new ValidateException(filterSectionMap.get(f), ValidateException.CODE_POSITION,
							ValidateException.EMSG_POSITION);
				}
			}
		}
	}

	/**
	 * 初始化模板
	 * 
	 * @throws IOException
	 * @throws ClassNotFoundException
	 * @throws InstantiationException
	 * @throws IllegalAccessException
	 */
	private void initFilters(Map<String, String> map) throws Exception {
		XStream xs = new XStream();
		xs.setMode(XStream.NO_REFERENCES);
		xs.processAnnotations(new Class[] { Template.class, FilterCfg.class, FieldCfg.class, CaseCfg.class,
				ComponentCfg.class, RelaFieldCfg.class });
		InputStream in = new ByteArrayInputStream(this.getRegxFile().getBytes("UTF-8"));
		Template template;
		try {
			template = (Template) xs.fromXML(in);
		} catch (Exception e) {
			throw e;
		}
		filterList = new ArrayList<Filter>();
		for (FilterCfg fcfg : template.getFilters()) {
			FilterImpl filter = new FilterImpl();
			filter.setType(fcfg.getType());
			filter.setSeperator(fcfg.getSeperator());
			filter.setStartWith(fcfg.getStartWith());
			filter.setFixLength(fcfg.getFixLength());
			filter.setFixRowNum(fcfg.getFixRowNum());
			filter.setErrorCode(fcfg.getErrorCode());
			filter.setOperators(fcfg.getOperators());

			List<Field> fieldlist = new ArrayList<Field>();
			for (FieldCfg cf : fcfg.getFields()) {
				Field field = new Field();
				field.setName(cf.getName());
				field.setRegx(cf.getRegx());
				field.setBegin(cf.getBegin());
				field.setEnd(cf.getEnd());
				field.setUnique(cf.getUnique());
				field.setRelated(cf.getRelated());
				field.setOperator(cf.getOperator());
				field.setComponent(cf.getComponent());
				field.setPassParam(cf.getPassParam());
				field.setFixValue(cf.getFixValue());
				field.setCases(cf.getCases());
				fieldlist.add(field);
			}
			filter.setFieldList(fieldlist);
			if (fcfg.getMatcher() != null && fcfg.getMatcher().length() > 0) {
				Class<?> cmacher = Class.forName(fcfg.getMatcher());
				FieldMatcher m = (FieldMatcher) cmacher.newInstance();
				m.setMap(map);
				filter.setFieldMatcher(m);
			} else {
				DefaultFieldMatcherImpl fieldMatcher = new DefaultFieldMatcherImpl();
				fieldMatcher.setMap(map);
				fieldMatcher.setOperators(fcfg.getOperators());
				filter.setFieldMatcher(fieldMatcher);
			}
			filterList.add(filter);
		}
		this.chain = new FilterChainImpl();
		chain.setFilterlist(filterList);
		minusRowNumChecker = new MinusRowNumChecker();
	}

	/**
	 * 把lines里面缓存的数据，写入临时文件
	 * 
	 * @author louiszhang
	 * @throws Exception
	 * @throws FileNotFoundException
	 * @date 2016-12-07
	 */
	private void copyToFile(String filePath) throws Exception {
		BufferedWriter bw = null;
		try {
			File file = new File(filePath);
			if (!file.exists()) {
				file.createNewFile();
			}
			OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(file, true));
			bw = new BufferedWriter(osw);

			for (String line : this.lines) {
				bw.write(line);
				bw.newLine();
			}
			bw.flush();
			bw.close();

			this.lines.clear();
		} catch (Exception e) {
			throw e;
		} finally {
		}
	}

	/**
	 * 对出错的行进行行级错误代码的插入（省boss文件专用）
	 * 
	 * @param line
	 * @return
	 * @author louiszhang
	 * @Date 2016-12-07
	 */
	private String addErrorCode(String line, String fileRecordingError, String type) {
		String newLine = "";

		if (FileHandleConstant.DATA_ROW_ERROR_CODE_YES_WITHOUT.equals(type)) {
			// 文件记录末尾无专门返回码字段
			newLine = line.substring(0, line.lastIndexOf("|") + 1) + "|" + fileRecordingError;
		} else {
			// 文件记录末尾有专门返回码字段
			newLine = line.substring(0, line.lastIndexOf("|") + 1) + fileRecordingError;
		}

		return newLine;
	}
}
