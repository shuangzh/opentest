package com.cmsz.cmup.fileImporting.service;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Value;

import com.cmsz.cmup.commons.ftp.FtpClientUtil;
import com.cmsz.cmup.commons.logging.alarm.AlarmLogHandler;
import com.cmsz.cmup.commons.logging.mapper.AlarmLogBean;
import com.cmsz.cmup.commons.logging.mapper.AlarmLogBeanMapper;
import com.cmsz.cmup.commons.logging.system.SystemLogHandler;
import com.cmsz.cmup.fileImporting.constant.FileHandleConstant;
import com.cmsz.cmup.fileImporting.dao.FileDataDAO;
import com.cmsz.cmup.fileImporting.dao.FileServiceInfoDAO;
import com.cmsz.cmup.fileImporting.dao.FileStatusDAO;
import com.cmsz.cmup.fileImporting.entity.FileStatusEntity;
import com.cmsz.cmup.fileImporting.handler.Handler;
import com.cmsz.cmup.fileImporting.utils.FileParamUtil;
import com.cmsz.cmup.fileImporting.validator.ValidateException;

/**
 * 基础服务处理
 * 
 * @author louiszhang
 *
 */
public abstract class BasicService {

	@Resource(name = "fileTransfer")
	private Handler fileTransfer;
	@Resource(name = "fileValidator")
	private Handler fileValidator;
	@Resource(name = "fileInsertDB")
	private Handler fileInsertDB;
	@Resource(name = "fileDirectTransHandler")
	private Handler fileDirectTransHandler;

	@Value("${errorFileBakPath}")
	String errorFileBakPath;
	@Value("${ftpRootPath}")
	private String ftpRootPath;
	@Value("${downloadFileslocalPath}")
	private String downloadFileslocalPath;

	@Resource
	FtpClientUtil ftpClientUtil;

	@Resource
	FileStatusDAO fileStatusDAO;
	@Resource
	FileDataDAO fileDataDAO;
	@Resource
	FileServiceInfoDAO fileServiceInfoDAO;
	@Resource
	AlarmLogBeanMapper alarmLogBeanMapper;

	private AlarmLogHandler alarmLogger = AlarmLogHandler.getLogger(this.getClass());
	private SystemLogHandler systemLogger = SystemLogHandler.getLogger(this.getClass());

	/**
	 * 获取文件类型配置信息
	 * 
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	public Map<String, String> getFileTypeInfo(Map<String, String> variableMap) throws Exception {
		Map<String, String> infoMap = new HashMap<>();

		try {
			infoMap = fileServiceInfoDAO.getFileInfo(variableMap);
		} catch (Exception e) {
			String ErrorMsg = "Exception happend while connecting to database, failed to get the file configuration..."
					+ "(" + "数据库连接出错，查询文件配置信息失败..." + ")";
			systemLogger.error(ErrorMsg, variableMap, e);
			alarmLogger.error(ErrorMsg, variableMap, e);
			throw e;
		}

		return infoMap;
	}

	/**
	 * 检查文件是否透传
	 * 
	 * @author louiszhang
	 * @time 20162016年8月15日下午2:47:34
	 * @param infoMap
	 * @param variableMap
	 * @return
	 */
	public boolean isDrectTrans(Map<String, String> infoMap, Map<String, String> variableMap) {
		if (FileHandleConstant.OUT_GOING_PATH_NONE.equals(infoMap.get(FileHandleConstant.OUT_GOING_PATH))) {
			String msgString = "According to the OUT_GOING_PATH configuration in the table FILE_SERVICE_INFO, there is no need to transport"
					+ infoMap.get(FileHandleConstant.FILE_TYPE_DESC) + "files, please check it mannully..." + "("
					+ "配置表显示" + infoMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件无需透传，请人工核实..." + ")";
			systemLogger.error(msgString, variableMap);
			alarmLogger.error(msgString, variableMap);
			return false;
		}
		if (!(FileHandleConstant.OUT_GOING_PATH.length() > 0)) {
			String msgString = "The OUT_GOING_PATH configuration of " + infoMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " files in the table FILE_SERVICE_INFO is not correct, please check it mannully..." + "(" + "配置表中"
					+ infoMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件的OUT_GOING_PATH配置项配置信息不正确，请人工核实..." + ")";
			systemLogger.error(msgString, variableMap);
			alarmLogger.error(msgString, variableMap);
			return false;
		}
		return true;
	}

	/**
	 * 初始化参数Map
	 * 
	 * @param fileParam
	 *            参数管理类
	 * @param fileStatusEntity
	 *            文件状态表实体类
	 * @return
	 */
	private Map<String, String> initialization(FileParamUtil fileParam, FileStatusEntity fileStatusEntity) {
		String errorFilePath;
		Map<String, String> variableMap = fileParam.getVariableMap();
		String fileName = fileStatusEntity.getFILE_NAME();

		Map<String, String> vaMap = new HashMap<>();
		vaMap.putAll(fileParam.getVariableMap());

		errorFilePath = errorFileBakPath + "/" + variableMap.get("busiLine") + "/error/";
		String localFilePath = downloadFileslocalPath + File.separator + fileName;

		if (!(fileParam.getVariableMap().get(FileHandleConstant.FILE_MERCHANT).length() > 0)) {
			vaMap.put(FileHandleConstant.FILE_MERCHANT, variableMap.get("busiLine"));
		}

		int fileOtherRows;
		fileOtherRows = Integer.parseInt(fileParam.getInfoMap().get(FileHandleConstant.FILE_OTHER_ROWS));

		// 原始文件名（不带时间戳）
		String origFileName = fileName.substring(0, fileName.lastIndexOf("_"));

		// 原始文件名（不带时间戳）
		vaMap.put(FileHandleConstant.ORIGINAL_FILE_NAME, origFileName);
		// 文件名（带时间戳）
		vaMap.put(FileHandleConstant.FILE_NAME, fileName);
		// 文件路径（带文件名,截去ftp根目录）
		vaMap.put(FileHandleConstant.FILE_PATH, fileStatusEntity.getFILE_PATH().substring(ftpRootPath.length()));
		// 文件序号（同批第几个文件）
		vaMap.put(FileHandleConstant.FILE_NO, Integer.toString(fileStatusEntity.getFILE_NO()));
		// 文件总数（同批文件总数）
		vaMap.put(FileHandleConstant.FILE_SUM, Integer.toString(fileStatusEntity.getFILE_SUM()));
		// 文件数据总数（数据行数加上文件头尾、签名行等）
		if (FileHandleConstant.IS_CHECK_LINE_COUNT_TRUE
				.equals(fileParam.getInfoMap().get(FileHandleConstant.IS_CHECK_LINE_COUNT))) {
			vaMap.put(FileHandleConstant.FILE_LINE_COUNT,
					Integer.parseInt(fileStatusEntity.getLINE_COUNT()) + fileOtherRows + "");
		} else {
			vaMap.put(FileHandleConstant.FILE_LINE_COUNT, FileHandleConstant.FILE_LINE_COUNT_NULL);
		}

		// 本地工作文件夹
		vaMap.put(FileHandleConstant.LOCAL_TEMP_FILES_DIRECTORY, downloadFileslocalPath);
		// 本地工作文件路径(带文件名）
		vaMap.put(FileHandleConstant.LOCAL_FILE_PATH, localFilePath);
		// 本地工作文件临时副本路径（带文件名，用于处理错误返回文件记录行尾加错误返回码等）
		vaMap.put(FileHandleConstant.LOCAL_TEMP_FILE_PATH, localFilePath + ".temp");
		// 错误文件备份路径
		vaMap.put(FileHandleConstant.ERROR_FILE_PATH, errorFilePath);

		// 校验是否通过标识
		vaMap.put(FileHandleConstant.FILE_VALIDATION_FLAG, "");
		// 入库是否成功标识
		vaMap.put(FileHandleConstant.FILE_INSERTDB_FLAG, "");

		return vaMap;
	}

	/**
	 * 获取已正常入库文件的状态数据
	 * 
	 * @author louiszhang
	 * @time 20162016年8月15日下午2:10:19
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	public List<FileStatusEntity> getInsertedDBFiles(Map<String, String> variableMap) throws Exception {
		// dealing with the situation that the "province" key in the variableMap
		// has the "null" value
		if (null == variableMap.get("province")) {
			variableMap.put("province", "");
		}
		// dealing with the situation that the variableMap does not contains the
		// key of province
		if (!variableMap.containsKey("province")) {
			variableMap.put("province", "");
		}

		List<FileStatusEntity> list = new ArrayList<>();
		try {
			list = fileStatusDAO.isInsertedDB(variableMap);
		} catch (Exception e) {
			String ErrorMsg = "Exception happend while connecting to database, failed to ckeck whether "
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + " files were put into database..." + "("
					+ "数据库连接出错，查询" + variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件是否入库成功状态失败..." + ")";
			systemLogger.error(ErrorMsg, variableMap, e);
			alarmLogger.error(ErrorMsg, variableMap, e);
			throw e;
		}

		return list;
	}

	/**
	 * 查询该查询该账期日该类文件是否已经正确入库（已经正确入库的文件跳过不处理）
	 * 
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	public boolean isInsertedDB(Map<String, String> variableMap) throws Exception {

		List<FileStatusEntity> list = new ArrayList<>();
		try {
			list = getInsertedDBFiles(variableMap);
		} catch (Exception e) {
			throw e;
		}
		if (list != null && list.size() > 0) {
			String msgString = variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " files have been put into database already, returning SUCCESS directly..." + "("
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件已经正确入库，直接返回处理成功..." + ")";
			systemLogger.info(msgString, variableMap);
			return true;
		} else {
			return false;
		}
	}

	/**
	 * 判断文件是否到达成功
	 * 
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	public List<FileStatusEntity> isArrived(Map<String, String> variableMap) {
		List<FileStatusEntity> list = new ArrayList<>();
		try {
			list = fileStatusDAO.checkFileStatus(variableMap);
		} catch (Exception e) {
			String ErrorMsg = "Exception happend while connecting to database, failed to ckeck whether "
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + " files were arrived properly..." + "("
					+ "数据库连接出错，查询" + variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件是否正确到达状态失败..." + ")";
			systemLogger.error(ErrorMsg, variableMap, e);
			alarmLogger.error(ErrorMsg, variableMap, e);
		}
		if (!(list != null && list.size() > 0)) {
			String msgString = variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " files are not arrived properly right now or failed to check the status of this kind of file, please try again later..."
					+ "(" + variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件尚未到达或查询文件状态失败，请稍后重试..." + ")";
			systemLogger.warn(msgString, variableMap);
			alarmLogger.warn(msgString, variableMap);
			AlarmLogBean alarmLogBean = new AlarmLogBean(msgString, variableMap.get("busiLine"),
					variableMap.get("province"), this.getClass());
			alarmLogBeanMapper.insert(alarmLogBean);

			return null;
		}
		return list;
	}

	/**
	 * 文件下载、校验、入库处理
	 * 
	 * @param fileParam
	 * @return
	 * @throws Exception
	 */
	public List<Map<String, String>> fileHandle(FileParamUtil fileParam) throws Exception {
		String ErrorMsg;
		List<Map<String, String>> mapList = new ArrayList<>();

		// 修改表状态为"正在处理中"
		fileStatusDAO.updateHandlingFileStatus(fileParam.getVariableMap());

		// 下载文件至本地
		for (FileStatusEntity fileStatusEntity : fileParam.getList()) {

			// 初始化
			Map<String, String> vMap = new HashMap<>();
			vMap = initialization(fileParam, fileStatusEntity);
			mapList.add(vMap);

			ErrorMsg = fileStatusEntity.getFILE_NAME() + ";start to handle "
					+ fileParam.getVariableMap().get(FileHandleConstant.FILE_TYPE_DESC) + " files..." + "(" + "开始处理"
					+ fileParam.getVariableMap().get(FileHandleConstant.FILE_TYPE_DESC) + "文件..." + ")";
			systemLogger.info(ErrorMsg, fileParam.getVariableMap());

			// 打印文件处理的基本参数
			String mapValues = fileStatusEntity.getFILE_NAME() + ";The basic parameters of handling the file are" + "("
					+ "文件处理基本参数为" + ") :";
			for (Map.Entry<String, String> entry : vMap.entrySet()) {
				mapValues += "key=" + entry.getKey() + "," + "value=" + entry.getValue() + "; ";
			}
			systemLogger.info(mapValues, fileParam.getVariableMap());

			// 判断文件转移至本地功能是否开启，若关闭则直接跳过
			if (vMap.containsKey(FileHandleConstant.FUNC_FILE_TRANSFER) && FileHandleConstant.FUNC_FILE_TRANSFER_DISABLE
					.equals(vMap.get(FileHandleConstant.FUNC_FILE_TRANSFER))) {
				ErrorMsg = "文件转移至本地工作目录功能被关闭，请确认是否允许。若允许，请确认" + vMap.get(FileHandleConstant.FILE_NAME)
						+ "文件已经存在于本地工作目录（" + vMap.get(FileHandleConstant.LOCAL_FILE_PATH) + "）中，以用于接下来的校验及入库等步骤！";
				systemLogger.info(ErrorMsg, vMap);
				continue;
			}

			// 第一步：下载文件
			try {
				// 下载文件
				fileTransfer.handle(vMap);
			} catch (Exception e) {
				ErrorMsg = vMap.get(FileHandleConstant.FILE_NAME) + ";" + vMap.get(FileHandleConstant.FILE_TYPE_DESC)
						+ " file;Exception happend while downloding the file, please try again later..." + "("
						+ vMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件下载出错，请稍后重试..." + ")";
				alarmLogger.error(ErrorMsg, vMap);
				systemLogger.error(ErrorMsg, vMap);
				// 错误文件处理(处理本地工作文件)
				localErrFilesHandle(mapList);
				throw e;
			}
		}

		// 第二步:校验文件
		ValidateException vException = null;
		for (Map<String, String> vMap : mapList) {

			// 判断文件校验功能是否开启，若关闭则打印日志后直接跳过
			if (vMap.containsKey(FileHandleConstant.FUNC_FILE_VALIDATION)
					&& FileHandleConstant.FUNC_FILE_VALIDATION_DISABLE
							.equals(vMap.get(FileHandleConstant.FUNC_FILE_VALIDATION))) {
				ErrorMsg = "文件校验功能已经被关闭，请确认是否允许。若允许，请确认正确的" + vMap.get(FileHandleConstant.FILE_TYPE_DESC)
						+ "对账文件已经存在与本地工作目录（" + vMap.get(FileHandleConstant.LOCAL_FILE_PATH) + "中，以用于接下来的入库等步骤！";
				systemLogger.info(ErrorMsg, vMap);
				continue;
			}

			try {
				fileValidator.handle(vMap);
			} catch (Exception e) {
				ErrorMsg = vMap.get(FileHandleConstant.FILE_NAME) + ";" + vMap.get(FileHandleConstant.FILE_TYPE_DESC)
						+ " file;Exception happend while validating the file, please ckeck up for the details manually..."
						+ "(" + vMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件校验出错，请检查..." + ")";

				// 校验不通过情况先不抛出异常，待全部文件校验完成后处理
				if (e instanceof ValidateException) {
					if (vException == null) {
						vException = new ValidateException(null, ValidateException.CODE_FAILED,
								ValidateException.EMSG_FAILED);
					}
					AlarmLogBean alarmLogBean = new AlarmLogBean(ErrorMsg, vMap.get("busiLine"), vMap.get("province"),
							this.getClass());
					alarmLogBeanMapper.insert(alarmLogBean);
					alarmLogger.warn(ErrorMsg, vMap);
					systemLogger.warn(ErrorMsg, vMap);
				} else {
					systemLogger.error(ErrorMsg, vMap);
					alarmLogger.error(ErrorMsg, vMap);
					throw e;
				}
			}
		}
		// 所有文件校验完成后抛出异常用于中断流程
		if (vException != null) {
			// 错误文件处理(处理本地工作文件和ftp备份文件)
			errorFilesHandle(fileParam.getVariableMap(), mapList, fileParam.getList());
			throw vException;
		}

		// 第三步：文件数据入库(全部文件)
		try {
			fileInDBHandle(fileParam.getVariableMap(), mapList);
		} catch (Exception e) {
			// 删除本地工作文件
			localErrFilesHandle(mapList);
			throw e;
		}

		return mapList;
	}

	/**
	 * 第三步：文件入库处理
	 * 
	 * @param variableMap
	 * @param mapList
	 * @throws Exception
	 */
	public void fileInDBHandle(Map<String, String> variableMap, List<Map<String, String>> mapList) throws Exception {
		String ErrorMsg;

		// 判断文件入库功能是否开启，若为关闭则直接跳过
		if (variableMap.containsKey(FileHandleConstant.FUNC_FILE_INSERTDB)
				&& FileHandleConstant.FUNC_FILE_INSERTDB_DISABLE
						.equals(variableMap.get(FileHandleConstant.FUNC_FILE_INSERTDB))) {
			ErrorMsg = "文件入库功能已被关闭，请确认是否允许。若允许，请确认对账所需数据已经在数据库表（" + variableMap.get(FileHandleConstant.FILE_DATA_TABLE)
					+ "）中";
			systemLogger.info(ErrorMsg, variableMap);
			return;
		}

		// 数据库表子分区名称
		String subpartition = getTablePartitionName(variableMap);
		variableMap.put("subpartition", subpartition);

		try {
			// 先尝试删除已入库的该日数据，保证入库最新数据
			ErrorMsg = "Start to delete the " + variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + " file "
					+ variableMap.get("settleDate") + " day's old data..." + "(" + "删除"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + variableMap.get("settleDate") + "日旧数据..."
					+ ")";
			systemLogger.info(ErrorMsg, variableMap);

			// confirm the mode of deleting the old file data
			if ("TRUNCATE_MODE".equals(variableMap.get("DELETE_DATA_MODE"))) {
				fileDataDAO.truncateSubpatirion(variableMap);
			} else {
				fileDataDAO.deleteStoredFileData(variableMap);
			}

			ErrorMsg = "Success to delete the " + variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + " file "
					+ variableMap.get("settleDate") + "day's old data, start to put the new file's data..." + "(" + "删除"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + variableMap.get("settleDate")
					+ "日旧数据成功，开始入库新数据..." + ")";
			systemLogger.info(ErrorMsg, variableMap);
		} catch (Exception e) {
			ErrorMsg = variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while dealing with the database, failed to delete the old data, please try again later..."
					+ "(" + variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件处理过程中连接数据库异常，删除旧数据失败，请稍后重试..."
					+ ")";
			alarmLogger.error(ErrorMsg, variableMap, e);
			systemLogger.error(ErrorMsg, variableMap, e);
			fileStatusDAO.updateArrivedFileStatus(variableMap);
			throw e;
		}

		// 进行入库新数据
		for (Map<String, String> map : mapList) {
			try {
				// 文件入库
				fileInsertDB.handle(map);
			} catch (Exception e) {
				ErrorMsg = map.get(FileHandleConstant.FILE_NAME) + ";"
						+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
						+ " file;Failed to store the file's data into database, please try again later..." + "("
						+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + "文件入库出错，请稍后重试..." + ")";
				alarmLogger.error(ErrorMsg, variableMap);
				systemLogger.error(ErrorMsg, variableMap);
				throw e;
			}
		}
	}

	/**
	 * get the table partition name 获得表分区名
	 * 
	 * @author louiszhang
	 * @time 20162016年8月26日上午10:04:48
	 * @param variableMap
	 * @return
	 */
	private String getTablePartitionName(Map<String, String> variableMap) {
		String tablePartitionPattern = variableMap.get(FileHandleConstant.TABLE_PARTITION_PATTERN);

		// 若配置项说明待删除表无分区配置，则直接返回null跳过处理
		if (FileHandleConstant.TABLE_PARTITION_PATTERN_NONE.equals(tablePartitionPattern)) {
			return "";
		}

		// 从参数map中取出组成分区名的参数值来组合成正确的分区名称
		StringBuilder partitionName = new StringBuilder();
		String partitionPrefix = tablePartitionPattern.substring(0, tablePartitionPattern.indexOf("_"));
		String[] patterns = tablePartitionPattern.substring((partitionPrefix.length() + 1)).split("_");
		partitionName.append(partitionPrefix);
		for (String pattern : patterns) {
			String patternValue = "_" + variableMap.get(pattern);
			partitionName.append(patternValue);
		}

		return partitionName.toString();
	}

	/**
	 * 文件透传处理
	 * 
	 * @author louiszhang
	 * @time 20162016年8月15日下午4:46:28
	 * @param fileParam
	 * @throws Exception
	 */
	public void fileDirectTransHandle(FileParamUtil fileParam) throws Exception {
		String msgString;

		msgString = fileParam.getVariableMap().get("fileTypeDesc")
				+ " files have been stored into database already, start to copy the files to outgoing folder..." + "("
				+ "文件已经正确入库，开始复制文件到透传下发目录..." + ")";
		systemLogger.info(msgString, fileParam.getVariableMap());

		for (FileStatusEntity fileStatusEntity : fileParam.getList()) {

			// 初始化
			Map<String, String> vMap = new HashMap<>();
			vMap = initialization(fileParam, fileStatusEntity);

			msgString = fileStatusEntity.getFILE_NAME() + ";start to handle "
					+ fileParam.getVariableMap().get(FileHandleConstant.FILE_TYPE_DESC) + " files..." + "(" + "开始透传"
					+ fileParam.getVariableMap().get(FileHandleConstant.FILE_TYPE_DESC) + "文件..." + ")";
			systemLogger.info(msgString, fileParam.getVariableMap());

			// 打印文件处理的基本参数
			String mapValues = fileStatusEntity.getFILE_NAME() + ";The basic parameters of handling the file are" + "("
					+ "文件处理基本参数为" + ") :";
			for (Map.Entry<String, String> entry : vMap.entrySet()) {
				mapValues += "key=" + entry.getKey() + "," + "value=" + entry.getValue() + "; ";
			}
			systemLogger.info(mapValues, fileParam.getVariableMap());

			try {
				fileDirectTransHandler.handle(vMap);
			} catch (Exception e) {
				msgString = vMap.get(FileHandleConstant.FILE_NAME) + ";" + vMap.get(FileHandleConstant.FILE_TYPE_DESC)
						+ " file;Exception happend while transporting the file directly from FTP server..." + "("
						+ "文件通过远程FTP透传出现错误..." + ")";
				alarmLogger.error(msgString, vMap);
				systemLogger.error(msgString, vMap);
				throw e;
			}
		}

	}

	/**
	 * 错误文件处理（处理ftp备份文件和本地工作文件）
	 * 
	 * @param variableMap
	 * @param mapList
	 * @throws Exception
	 */
	private void errorFilesHandle(Map<String, String> variableMap, List<Map<String, String>> mapList,
			List<FileStatusEntity> list) throws Exception {

		// 首先将工作文件全部删除
		localErrFilesHandle(mapList);

		// 根据情况删除ftp备份的文件
		if (FileHandleConstant.ERROR_FILE_DELETE_ALL.equals(variableMap.get(FileHandleConstant.ERROR_FILE_DELETE))) {
			for (FileStatusEntity fileStatusEntitiy : list) {
				String errFtpBakFilePath = fileStatusEntitiy.getFILE_PATH().substring(ftpRootPath.length());
				int errorFilePathLength = errFtpBakFilePath.lastIndexOf("/");
				String errorFilePath = errFtpBakFilePath.substring(0, errorFilePathLength);
				String msgString;
				String[] fileNames;

				// 先判断文件存不存在
				fileNames = ftpClientUtil.listNames(errorFilePath);
				for (String fileName : fileNames) {
					if (errFtpBakFilePath.equals(fileName)) {
						try {
							if (ftpClientUtil.deleteFile(errFtpBakFilePath)) {
								msgString = "Successful to delete the error file：" + fileStatusEntitiy.getFILE_PATH()
										+ " in the error file folder..." + "(" + "删除ftp备份文件夹下错误文件："
										+ fileStatusEntitiy.getFILE_PATH() + "成功..." + ")";
								systemLogger.info(msgString, variableMap);
							} else {
								msgString = "Failed to delete the error file：" + fileStatusEntitiy.getFILE_PATH()
										+ ", please handle this manually..." + "(" + "删除ftp备份文件夹下错误文件："
										+ fileStatusEntitiy.getFILE_PATH() + "失败，请人工处理..." + ")";
								systemLogger.error(msgString, variableMap);
								alarmLogger.error(msgString, variableMap);
							}
						} catch (Exception e) {
							msgString = "Exception happend while deleting the "
									+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
									+ " error files in the backup folder, please delete the error files manually..."
									+ "(" + "删除ftp备份文件夹下" + variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
									+ "错误文件失败，请人工删除所有相关错误文件..." + ")";
							systemLogger.error(msgString, variableMap, e);
							alarmLogger.error(msgString, variableMap, e);
						}
					}
				}
			}
		}

		// 同批次非错误文件状态回退
		fileStatusDAO.updateArrivedFileStatus(variableMap);
	}

	/**
	 * 本地工作文件处理
	 * 
	 * @param mapList
	 */
	private void localErrFilesHandle(List<Map<String, String>> mapList) {
		// 首先将工作文件全部删除（包括临时工作文件副本）
		for (Map<String, String> map : mapList) {
			// 删除错误下载的文件
			File errFile = new File(map.get(FileHandleConstant.LOCAL_FILE_PATH));
			if (errFile.exists()) {
				errFile.delete();
			}

			// 删除临时工作文件副本
			File localTempFile = new File(map.get(FileHandleConstant.LOCAL_TEMP_FILE_PATH));
			if (localTempFile.exists()) {
				localTempFile.delete();
			}
		}
	}

	public Handler getFileTransfer() {
		return fileTransfer;
	}

	public void setFileTransfer(Handler fileTransfer) {
		this.fileTransfer = fileTransfer;
	}

	public Handler getFileValidator() {
		return fileValidator;
	}

	public void setFileValidator(Handler fileValidator) {
		this.fileValidator = fileValidator;
	}

	public Handler getFileInsertDB() {
		return fileInsertDB;
	}

	public void setFileInsertDB(Handler fileInsertDB) {
		this.fileInsertDB = fileInsertDB;
	}
}
