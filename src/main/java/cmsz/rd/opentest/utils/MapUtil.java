package cmsz.rd.opentest.utils;

import org.apache.commons.lang.StringUtils;

import java.util.*;

/**
 * Created by admin on 2017/5/3.
 */
public class MapUtil {

    public static Map EMPTYMAP = new HashMap();

//    /**
//     * 移除map中的key-value对， 并返回新的map
//     * @param map
//     * @param removes   需要移除的key 数组
//     * @param ignoreCase    是否忽略 key字符的大小写
//     * @return
//     */
//    public static  Map<String, String>  remove(Map<String, String>  map, String[] removes, boolean ignoreCase){
//        HashMap nmap =new HashMap();
//        HashSet<String> iset = null;
//        if(removes != null){
//            iset = new HashSet<>();
//            for (String s: removes){
//                if(StringUtils.isBlank(s))
//                    continue;
//                if(ignoreCase)
//                    iset.add(s.trim().toLowerCase());
//                else
//                    iset.add(s.trim());
//            }
//            if(iset.size()==0 ){
//                 iset = null;
//            }
//        }
//
//        for(String k : map.keySet()){
//            String nk=k.trim();
//            if(ignoreCase)
//                nk = nk.toLowerCase();
//            if(iset != null && iset.contains(nk)){
//                continue;
//            }else {
//                nmap.put(nk, map.get(k));
//            }
//        }
//        return  nmap;
//    }
//
//    public static Map<String, String> remove(Map<String, String> map, String[] removes){
//        return  remove(map, removes, true);
//    }
//
//    /**
//     * 移除map中的key-value对， 并返回新的map
//     * @param map
//     * @param removes    采用 , 分隔需要移除的key
//     * @param ignoreCase
//     * @return
//     */
//    public static  Map<String, String>  remove(Map<String, String>  map, String removes, boolean ignoreCase){
//        String[] rs = removes.split(",");
//        return  remove(map, rs, ignoreCase);
//    }
//
//    public static  Map<String, String>  remove(Map<String, String>  map, String removes){
//        return remove(map, removes, true);
//    }
//
//
//    /**
//     * 移除List<Map<String, String> 中的列
//     * @param list
//     * @param removes      列名，以数组形式
//     * @param ignoreCase
//     * @return
//     */
//    public static List<Map<String, String>> removeColumn(List<Map<String,String>> list, String[] removes, boolean ignoreCase){
//        List<Map<String, String>> nlist = new ArrayList<>();
//        for(int i=0; i<list.size(); i++){
//            nlist.add(remove(list.get(i), removes, ignoreCase));
//        }
//        return  nlist;
//    }
//
//    public static List<Map<String, String>> removeColumn(List<Map<String,String>> list, String[] removes){
//        return removeColumn(list, removes, true);
//    }
//
//    /**
//     * 移除List<Map<String, String> 中的列
//     * @param list
//     * @param removes   列名，以 ,分隔形式
//     * @param ignoreCase
//     * @return
//     */
//    public static List<Map<String, String>> removeColumn(List<Map<String,String>> list, String removes, boolean ignoreCase){
//        String[] rs = removes.split(",");
//        return  removeColumn(list, rs, ignoreCase);
//    }
//
//    public static List<Map<String, String>> removeColumn(List<Map<String,String>> list, String removes){
//        return  removeColumn(list, removes, true);
//    }


    public static Map<String, String> remove(Map<String, String> src, Set<String> removes) {
        HashMap<String, String> nmap = new HashMap<>(src);
        if (removes != null) {
            for (String k : removes) {
                nmap.remove(k);
            }
        }
        return nmap;
    }

    public static Map<String, String> remove(Map<String, String> src, String[] removes) {
        HashMap<String, String> nmap = new HashMap<>(src);
        if (removes != null) {
            for (String k : removes) {
                nmap.remove(k);
            }
        }
        return nmap;
    }

    public static Map<String, String> remove(Map<String, String> src, String removes) {
        String[] sa=null;
        if(removes!=null){
            sa = removes.split(",");
        }
        return remove(src, sa);
    }

    public static List<Map<String, String>> removeColumn(List<Map<String, String>> list, Set<String> removes) {
        List<Map<String, String>> nlist = new ArrayList<>(list);
        for (int i = 0; i < nlist.size(); i++) {
            nlist.set(i, remove(nlist.get(i), removes));
        }
        return nlist;
    }

    public static List<Map<String, String>> removeColumn(List<Map<String, String>> list, String[] removes) {
        List<Map<String, String>> nlist = new ArrayList<>(list);
        for (int i = 0; i < nlist.size(); i++) {
            nlist.set(i, remove(nlist.get(i), removes));
        }
        return nlist;
    }


    public static List<Map<String, String>> removeColumn(List<Map<String, String>> list, String removes) {
        String[] rsa = null;
        if(removes!=null)
            rsa = removes.split(",");
        return removeColumn(list, rsa);
    }


    public static Map<String, String> renameKey(Map<String, String> src, Map<String, String> nkeys) {
        HashMap<String, String> nmap = new HashMap<>(src);
        if (nkeys != null) {
            for (String k : nmap.keySet()) {
                if (nkeys.keySet().contains(k)) {
                    nmap.put(nkeys.get(k), nmap.get(k));
                    nmap.remove(k);
                }
            }
        }
        return nmap;
    }

    public static List<Map<String, String>> renameColunmKey(List<Map<String, String>> list, Map<String, String> nkeys) {
        List<Map<String, String>> nlist = new ArrayList<>(list);
        for (int i = 0; i < nlist.size(); i++) {
            nlist.set(i, renameKey(nlist.get(i), nkeys));
        }
        return nlist;
    }

    public static boolean contain(Map<String, String> actul, Map<String, String> expect, boolean ignoreCase) {
        for (String k : expect.keySet()) {
            if (actul.keySet().contains(k)) {
                if (ignoreCase) {
                    if (actul.get(k).compareToIgnoreCase(expect.get(k)) != 0) {
                        return false;
                    }
                } else {
                    if (actul.get(k).compareTo(expect.get(k)) != 0) {
                        return false;
                    }
                }
            } else {
                return false;
            }
        }
        return true;
    }


    public static Map<String, String> find(List<Map<String, String>> list, String keycolumn, String value) {
        for (Map m : list) {
            if (m.get(keycolumn).equals(value))
                return m;
        }
        return null;
    }


    public static Map<Map, Map> findNotMatched(List<Map<String, String>> list, Map<String, String> expect, String keycolumn) {
        HashMap<Map, Map> rmap = new HashMap<>();
        String value = expect.get(keycolumn);
        if (value == null) {
            rmap.put(expect, EMPTYMAP);
            return rmap;
        }

        Map act = find(list, keycolumn, value);
        if (act == null) {
            rmap.put(expect, EMPTYMAP);
            return rmap;
        }

        if (!contain(act, expect, false)) {
            rmap.put(expect, act);
            return rmap;
        }
        return null;

    }


    public static List<Map> findNotMatched(List<Map<String, String>> actlist, List<Map<String, String>> expectList, String keycolumn) {
        ArrayList<Map> rlist = new ArrayList<>();
        for (int i = 0; i < expectList.size(); i++) {
            Map m = findNotMatched(actlist, expectList.get(i), keycolumn);
            if (m != null) {
                rlist.add(m);
            }
        }
        if (rlist.size() == 0)
            return null;
        return rlist;
    }

}
