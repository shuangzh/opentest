package cmsz.rd.opentest.cmd;

import org.apache.commons.lang.StringUtils;
import org.omg.SendingContext.RunTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeoutException;

/**
 * Created by admin on 2017/4/12.
 */
public class DefaultCmdProcess implements CmdProcess {

    Logger logger = LoggerFactory.getLogger(getClass());

    protected String cmdLine;

    private Process process;

    private File file;

    private Thread thread;

    private BufferedWriter bw;

    private volatile String lastLine;

    private volatile Integer exitValue = null;

    private List<Checker> checkers = new ArrayList<>();

    private Blocker blocker = null;

    private volatile boolean stoped = false;

    public DefaultCmdProcess(String cmdLine) {
        this.cmdLine = cmdLine;
    }

    public DefaultCmdProcess() {
    }

    public void setCmdLine(String cmdline) {
        this.cmdLine = cmdline;
    }

    public String getProcessName() {
        return cmdLine;
    }

    public void start() {
        Runtime rt = Runtime.getRuntime();
        try {
            process = rt.exec(cmdLine);
            file = File.createTempFile("OTCMD_", ".out");
            bw = new BufferedWriter(new FileWriter(file));
        } catch (IOException e) {
            e.printStackTrace();
            throw new RuntimeException("Start process failed : " + cmdLine, e);
        }

        thread = new Thread(new Runnable() {
            public void run() {
                BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
                BufferedReader ebr = new BufferedReader(new InputStreamReader(process.getErrorStream()));

                // 读取标准错误输出
                Thread ethread = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        String eline = null;
                        try {
                            while ((eline = ebr.readLine()) != null) {
                                handleLine(eline);
                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                });
                ethread.setDaemon(true);
                ethread.start();

                String line = null;
                try {
                    while ((line = br.readLine()) != null) {
                        handleLine(line);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }

                try {
                    ethread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

//                boolean flag1 = false;
//                boolean flag2 = false;
//                try {
//                    // 循环读取标准输出
//                    for (; ; ) {
//
//                        if (flag1 && flag2)
//                            break;
//                        if (!flag1) {
//                            for (int k = 10; k > 0; k--) {
//                                flag1 = (line = br.readLine()) == null ? true : false;
//                                handleLine(line);
//                            }
//                        }
//
//                        if (!flag2) {
//                            for (int j = 10; j > 0; j--) {
//                                flag2 = (line = ebr.readLine()) == null ? true : false;
//                                handleLine(line);
//                            }
//                        }
//                    }
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }

                try {
                    br.close();
                    ebr.close();
                    bw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                try {
                    exitValue = process.waitFor();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                logger.debug("process :" + cmdLine + " terminalled");
            }
        });
        thread.setDaemon(true);
        thread.start();
    }

    synchronized private void handleLine(String line) throws IOException {
        if (line == null)
            return;
        logger.debug(line);

        // 写入到临时文件
        bw.write(line + "\r\n");

        // 错误检查
        for (Checker c : checkers) {
            c.check(line);
        }
        // 阻塞检查
        if (blocker != null) {
            blocker.watch(line);
        }

        // 设置lastLine
        if (StringUtils.isNotBlank(line))
            lastLine = line;
    }

    public Integer waitFor() {
        if (exitValue != null)
            return exitValue;
        else {
            for(;;){
            try {
                int ret = process.waitFor();
                thread.join();
                exitValue = ret;
                return ret;
            } catch (InterruptedException e) {
                e.printStackTrace();
                this.detectCheckers();
                }
            }
        }

    }

    public File getStdoutFile() {
        return file;
    }

    public String getLastStdoutLine() {
        return lastLine;
    }

    public boolean isAlive() {
        return process.isAlive();
    }

    public Integer exitValue() {
        return waitFor();
    }

    public void destroy() {
        process.destroy();
    }

    public String getCmdLine() {
        return cmdLine;
    }


    @Override
    public void addChecker(Checker checker) {
        if (checker != null)
            checkers.add(checker);
    }

    @Override
    public void registerBlocker(Blocker blocker) {
        this.blocker = blocker;
    }


//    public void inspect() {
//        for (; ; ) {
//            detectCheckers();
//            if (blocker != null) {
//                if (blocker.isSatisfied()) {
//                    detectCheckers();
//                    break;
//                } else {
//                    try {
//                        Thread.sleep(500);
//                    } catch (InterruptedException e) {
//                        e.printStackTrace();
//                    }
//
//                }
//            } else {
//                break;
//            }
//        }
//    }

    public void detectCheckers() {
        if (checkers != null) {
            boolean has = false;
            String msg = "";
            for (Checker c : checkers) {
                logger.debug("detect checker @" + c.toString());
                if (c.hasError()) {
                    has = true;
                    msg = msg + c.getErrorMsg() + "\n";
                }
            }
            if (has) {
                logger.info("checkers detect errors: "+ msg);
                throw new RuntimeException(msg);
            }
        }
    }

    public void joinBlocker() {
        if(blocker == null){
            logger.info("blocker is null, passed !");
        }
        for (; ; ) {
            if (this.blocker.isSatisfied()) {
                logger.debug("Blocker is satisfied");
                break;
            } else {
                logger.debug("Blocker is not satisfied, wait 1 second to check again");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
//                    e.printStackTrace();
                    logger.debug(e.getMessage() +" @@@joinBlocker()");
                    this.detectCheckers();
                }
            }
        }
    }

    public void joinBlocker(double second) {
        long tt = (long) (second * 1000);

        if(blocker == null){
            logger.info("blocker is null, passed !");
        }

        for (; ; ) {
            if (this.blocker.isSatisfied()) {
                logger.debug("Blocker is satisfied");
                break;
            } else {
                logger.debug("Blocker is not satisfied, wait 1 second to check again");
                try {
                    Thread.sleep(1000);
                    tt = tt - 1000;
                    if (tt < 0) {
                        throw new RuntimeException("joinBlocker timeout");
                    }
                } catch (InterruptedException e) {
 //                   e.printStackTrace();
                    logger.debug(e.getMessage() +" @@@joinBlocker()");
                    this.detectCheckers();
                }
            }
        }
    }


//    public void inspect(int timeout) {
//        int tt = timeout * 1000;
//        for (; ; ) {
//            detectCheckers();
//            if (blocker != null) {
//                if (blocker.isSatisfied()) {
//                    detectCheckers();
//                    break;
//                } else {
//                    try {
//
//                        if (timeout > 0 && tt < 0) {
//                            throw new RuntimeException("blocker not satisfied, time out  " + timeout);
//                        }
//
//                        Thread.sleep(500);
//                        tt = tt - 500;
//
//                    } catch (InterruptedException e) {
//                        e.printStackTrace();
//                    }
//
//                }
//            } else {
//                break;
//            }
//        }
//
//    }


}
