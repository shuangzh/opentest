package cmsz.rd.opentest.database;

import cmsz.rd.opentest.exceptions.NoExistException;
import cmsz.rd.opentest.exceptions.NotEqualException;
import cmsz.rd.opentest.exceptions.ParamValidException;
import cmsz.rd.opentest.exceptions.TypeMatchException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by admin on 2017/4/13.
 */
public class QueryAssert {

    private Logger logger = LoggerFactory.getLogger(getClass());

    List<Map<String, Object>> datas = null;

    public static QueryAssert query(String selectSql, String dbname) {
        selectSql = selectSql.trim();
        JdbcTemplate jdbcTemplate = DatabaseBuilder.getJdbcTemple(dbname);
        QueryAssert queryAssert = new QueryAssert();
        queryAssert.datas = jdbcTemplate.queryForList(selectSql);
        
//        Map<String, Object> row = queryAssert.datas.get(0);
//
//        for (String key : row.keySet()) {
//            Object value = row.get(key);
//            System.out.println("cloumn -- " + key);
//            if (value != null) {
//                System.out.println(value.getClass().getName());
//                System.out.println(value.getClass().getTypeName());
//            }
//        }

        return queryAssert;
    }

    public void assertHasRecord(String keyColumn, Object expkeyValue, Object... objects) {

        if (objects != null) {
            if (objects.length % 2 != 0)
                throw new ParamValidException();
            if (objects.length > 0) {
                for (int i = 0; i < objects.length; i = i + 2) {
                    if (objects[i] instanceof String) {
                        continue;
                    } else throw new ParamValidException();
                }
            }
        }

        for (Map<String, Object> row : datas) {
            Object actual = row.get(keyColumn);
            if (ObjectCompare(expkeyValue, actual)) {
                if (objects == null)
                    return;
                else {
                    if (objects.length > 0) {
                        Map<String, Object> eactmap = new HashMap<String, Object>();
                        Map<String, Object> eexpmap = new HashMap<String, Object>();
                        for (int i = 0; i < objects.length - 1; i = i + 2) {
                            Object expect = objects[i + 1];
                            Object act = row.get(objects[i]);
                            if (act == null && expect == null)
                                continue;

                            if ((act == null && expect != null) || (act != null && expect == null)) {
                                eactmap.put((String) objects[i], act);
                                eexpmap.put((String) objects[i], expect);
                                continue;
                            }

                            if (ObjectCompare(expect, act))
                                continue;
                            else {
                                eactmap.put((String) objects[i], act);
                                eexpmap.put((String) objects[i], expect);
                                continue;
                            }
                        }
                        if (eactmap.isEmpty())
                            return;
                        else
                            throw new NotEqualException();
                    }else {
                        return;
                    }
                }
            } else continue;
        }
        throw new NoExistException();
    }

    private boolean ObjectCompare(Object expected, Object actul) {
        int res = -1;

        if (actul instanceof BigDecimal) {
            if (expected instanceof Integer) {
                res = ((BigDecimal) actul).compareTo(BigDecimal.valueOf((Integer) expected));
            } else if (expected instanceof Long) {
                res = ((BigDecimal) actul).compareTo(BigDecimal.valueOf((Long) expected));
            } else if (expected instanceof Double) {
                res = ((BigDecimal) actul).compareTo(BigDecimal.valueOf((Double) expected));
            } else if (expected instanceof Float) {
                res = ((BigDecimal) actul).compareTo(BigDecimal.valueOf((Float) expected));
            } else if (expected instanceof String) {
                res = ((BigDecimal) actul).compareTo(new BigDecimal((String) expected));
            } else if (expected instanceof BigInteger) {
                res = ((BigDecimal) actul).compareTo(new BigDecimal((BigInteger) expected));
            } else {
                throw new TypeMatchException();
            }
        } else if (actul instanceof String) {

            if (expected instanceof String) {
                res = ((String) actul).compareTo((String) expected);
            } else {
                throw new TypeMatchException();
            }

        }

        if (res == 0)
            return true;
        else
            return false;
    }

//    private boolean isIntegerType(Object actual) {
//        if (actual instanceof Integer || actual instanceof Long || actual instanceof Short) {
//            return true;
//        } else
//            return false;
//    }
//
//    private boolean isNumberType(Object actual) {
//        if (isIntegerType(actual) || actual instanceof Double || actual instanceof Float)
//            return true;
//        else
//            return false;
//    }


}
