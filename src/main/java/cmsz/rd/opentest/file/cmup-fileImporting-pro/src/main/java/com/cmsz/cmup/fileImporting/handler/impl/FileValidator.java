package com.cmsz.cmup.fileImporting.handler.impl;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.cmsz.cmup.commons.ftp.FtpClientUtil;
import com.cmsz.cmup.commons.logging.alarm.AlarmLogHandler;
import com.cmsz.cmup.commons.logging.mapper.AlarmLogBean;
import com.cmsz.cmup.commons.logging.mapper.AlarmLogBeanMapper;
import com.cmsz.cmup.commons.logging.system.SystemLogHandler;
import com.cmsz.cmup.commons.utils.FileLinesDataUtil;
import com.cmsz.cmup.fileImporting.constant.FileHandleConstant;
import com.cmsz.cmup.fileImporting.dao.FileServiceInfoDAO;
import com.cmsz.cmup.fileImporting.dao.FileStatusDAO;
import com.cmsz.cmup.fileImporting.entity.FileServiceInfoEntity;
import com.cmsz.cmup.fileImporting.handler.Handler;
import com.cmsz.cmup.fileImporting.validator.ValidateException;
import com.cmsz.cmup.fileImporting.validator.impl.ValidatorImpl;

/**
 * 文件校验处理类
 * 
 * @author louiszhang
 * @time 20162016年4月20日下午4:36:04
 */
@Component
public class FileValidator implements Handler {
	private static AlarmLogHandler alarmLogger = AlarmLogHandler.getLogger(FileValidator.class);
	private static SystemLogHandler systemLogger = SystemLogHandler.getLogger(FileValidator.class);

	@Value("${ftpRootPath}")
	private String ftpRootPath;
	@Value("${fileEndRegx}")
	private String fileEndRegx;
	@Value("${fileEndErrorCode}")
	private String fileEndErrorCode;
	@Resource
	FtpClientUtil ftpClientUtil;
	@Resource
	FileStatusDAO fileStatusDAO;
	@Resource
	FileServiceInfoDAO fileServiceInfoDAO;
	@Resource
	AlarmLogBeanMapper alarmLogBeanMapper;
	@Resource
	FileLinesDataUtil fileLinesDataUtil;

	Map<String, FileServiceInfoEntity> fileServiceInfoEntityMap = new HashMap<String, FileServiceInfoEntity>();

	@Override
	public Map<String, String> handle(Map<String, String> variableMap) throws Exception {
		String msgContext;
		File file;
		FileInputStream fStream = null;

		msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
				+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + " file;Start to validate the file's data..."
				+ "(" + "文件开始校验..." + ")";
		systemLogger.info(msgContext, variableMap);

		// 校验文件最后一行空行是否存在
		try {
			if (!isFinalBlankLineExists(variableMap)) {
				msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
						+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
						+ " file;Missing of the blank line in the file end, file validation failed..." + "("
						+ "文件缺少最后一行空行，校验失败..." + ")";
				ValidateException vException = new ValidateException(null, ValidateException.CODE_FAILED, msgContext);
				vException.append(vException);
				errorFileHandler(variableMap, vException);
				throw vException;
			}
		} catch (Exception e) {
			throw e;
		}

		// 校验文件尾
		try {
			checkFileEnd(variableMap);
		} catch (Exception e) {
			throw e;
		}

		try {
			file = new File(variableMap.get(FileHandleConstant.LOCAL_FILE_PATH));
			fStream = new FileInputStream(file);
		} catch (Exception e) {
			String errmsg = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while access file, the file is not found in the local work folder, file validation failed..."
					+ "(" + "文件获取异常，本地目录未找到该文件，校验失败..." + ")";
			alarmLogger.error(errmsg, variableMap, e);
			systemLogger.error(errmsg, variableMap, e);
			fileStatusDAO.updateArrivedFileStatus(variableMap);

			if (fStream != null) {
				fStream.close();
			}
			throw e;
		}

		try {
			// 开始文件校验
			ValidatorImpl validator = new ValidatorImpl();
			String regxTplContent = getRegxTplContent(variableMap);
			validator.setRegxFile(regxTplContent);
			validator.validate(fStream, variableMap);
		} catch (Exception e) {

			if (e instanceof ValidateException) {
				// 校验不通过，进行错误文件处理流程
				errorFileHandler(variableMap, (ValidateException) e);
			} else {
				msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
						+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
						+ " file;Exception happend while validating the file, file validation failed..." + "("
						+ "文件校验操作出现异常，校验失败..." + ")";
				alarmLogger.error(msgContext, variableMap, e);
				systemLogger.error(msgContext, variableMap, e);
				fileStatusDAO.updateArrivedFileStatus(variableMap);
			}

			throw e;
		} finally {
			fStream.close();
		}

		msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
				+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC) + " file;Finish for the file validation..." + "("
				+ "文件检验完成..." + ")";
		systemLogger.info(msgContext, variableMap);

		return null;
	}

	/**
	 * 文件最后回车换行（即文件最后需有一行空行）校验
	 * 
	 * @param map
	 * @param localFilePath
	 * @return
	 * @throws Exception
	 */
	private boolean isFinalBlankLineExists(Map<String, String> map) throws Exception {

		// 不校验空行直接返回true
		if (FileHandleConstant.CHECK_FINAL_BLANK_LINE_NO
				.equals(map.get(FileHandleConstant.IS_CHECK_FINAL_BLANK_LINE))) {
			return true;
		}

		boolean b = false;
		RandomAccessFile rAccessFile = null;
		String finalLine = null;
		try {
			rAccessFile = new RandomAccessFile(map.get(FileHandleConstant.LOCAL_FILE_PATH), "r");
			// 如果为空文件返回ture，不校验最后回车空行
			if (rAccessFile.length() == 0) {
				b = true;
			} else {
				rAccessFile.seek(rAccessFile.length() - 1);
				int c = -1;
				c = rAccessFile.read();
				if (c == '\n') {
					finalLine = rAccessFile.readLine();
					if (finalLine == null) {
						b = true;
					}
				}
			}
		} catch (Exception e) {
			String msgContext = map.get(FileHandleConstant.FILE_NAME) + ";" + map.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while validating the file, file validation failed..." + "("
					+ "文件校验操作出现异常，校验失败..." + ")";
			alarmLogger.error(msgContext, map, e);
			systemLogger.error(msgContext, map, e);
			fileStatusDAO.updateArrivedFileStatus(map);
			throw e;
		} finally {
			if (null != rAccessFile) {
				rAccessFile.close();
			}
		}

		return b;
	}

	/**
	 * 文件尾校验器
	 * 
	 * @param map
	 * @throws Exception
	 */
	private void checkFileEnd(Map<String, String> map) throws Exception {
		// 获得文件尾
		String endLine = null;
		if (FileHandleConstant.FILE_ENDLINE_FINAL.equals(map.get(FileHandleConstant.FILE_ENDLINE))) {
			// 文件尾为文件最后一行
			endLine = fileLinesDataUtil.getFinalLineData(map);
		} else if (FileHandleConstant.FILE_ENDLINE_PENULTIMATE.equals(map.get(FileHandleConstant.FILE_ENDLINE))) {
			// 文件尾为文件倒数第二行（即带签名文件）
			endLine = fileLinesDataUtil.getPenultimateData(map);
		} else {
			// 无文件尾
			return;
		}

		String msgContext = null;
		if (endLine == null || endLine.length() == 0 || !(endLine.matches(fileEndRegx))) {
			msgContext = map.get(FileHandleConstant.FILE_NAME) + ";" + map.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Error in the file end, file validation failed..." + "(" + "文件尾异常，校验失败..." + ")";
			ValidateException vException = new ValidateException(null, fileEndErrorCode, msgContext);
			vException.append(vException);
			errorFileHandler(map, vException);
			throw vException;
		}
	}

	/**
	 * 错误文件处理(转移错误文件至错误备份文件夹,更新文件状态表等)
	 * 
	 * @param map
	 * @throws IOException
	 */
	public void errorFileHandler(Map<String, String> map, ValidateException ve) throws IOException {
		String errorFilePath = map.get(FileHandleConstant.ERROR_FILE_PATH);
		String returnCode = null;
		String errorFileName = null;
		List<ValidateException> vList = new LinkedList<>();
		vList = ve.trace();

		// 获取错误文件返回码（第一次出错的错误类型返回码）
		if (vList.size() > 1) {
			returnCode = vList.get(1).getCode();
		} else {
			returnCode = vList.get(0).getCode();
		}

		// 生成错误文件名
		String origFileName = map.get(FileHandleConstant.ORIGINAL_FILE_NAME);
		String[] fileNamePattern = origFileName.split("\\.");
		if (fileNamePattern.length == 3) {
			errorFileName = returnCode + fileNamePattern[0] + "." + fileNamePattern[2] + "." + fileNamePattern[1];
		} else {
			errorFileName = returnCode + origFileName;
		}

		// 打印错误日志，插入告警表
		for (ValidateException validateException : vList) {
			String msgContext = map.get(FileHandleConstant.FILE_NAME) + ";" + map.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Error in the file data, file validation failed..." + "(" + "文件数据有误，校验失败..." + ")"
					+ validateException.toString();
			alarmLogger.warn(msgContext, map, validateException);
			systemLogger.warn(msgContext, map, validateException);
			AlarmLogBean alarmLogBean = new AlarmLogBean(msgContext, map.get("busiLine"), map.get("province"),
					this.getClass());
			alarmLogBeanMapper.insert(alarmLogBean);
			returnCode = validateException.getCode();
		}

		// 转移错误文件至错误备份文件夹
		FileInputStream localFileIS = null;
		if (map.get(FileHandleConstant.DATA_ROW_ERROR_CODE).matches("^YES.*$")) {
			localFileIS = new FileInputStream(map.get(FileHandleConstant.LOCAL_TEMP_FILE_PATH));
		} else {
			localFileIS = new FileInputStream(map.get(FileHandleConstant.LOCAL_FILE_PATH));
		}
		try {
			ftpClientUtil.put(localFileIS, errorFilePath, errorFileName, null);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			String msgContext = map.get(FileHandleConstant.FILE_NAME) + ";" + map.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " error file;Exception happend while uploading the error file into the error file backup folder..."
					+ "(" + "错误文件上传错误备份文件夹失败..." + ")";
			alarmLogger.error(msgContext, map, e);
			systemLogger.error(msgContext, map, e);
		} finally {
			localFileIS.close();
		}

		// 删除错误文件
		try {
			if (!(ftpClientUtil.deleteFile(map.get(FileHandleConstant.FILE_PATH)))) {
				String msgContext = map.get(FileHandleConstant.FILE_NAME) + ";"
						+ map.get(FileHandleConstant.FILE_TYPE_DESC)
						+ " error file;Failed to delete the error file in the FTP server, please delete the error file manually..."
						+ "(" + "错误文件FTP上删除失败,请手动删除..." + ")";
				alarmLogger.error(msgContext, map);
				systemLogger.error(msgContext, map);
			}
		} catch (Exception e) {
			String msgContext = map.get(FileHandleConstant.FILE_NAME) + ";" + map.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " error file;Exception happend while deleting the error file..." + "(" + "错误文件删除失败..." + ")";
			alarmLogger.error(msgContext, map, e);
			systemLogger.error(msgContext, map, e);
		}

		// 错误文件全路径（即带错误文件名）
		String errorFileFullPath = ftpRootPath + errorFilePath + errorFileName;
		map.put(FileHandleConstant.ERROR_FILE_PATH, errorFileFullPath);

		// 更新文件状态表（更新文件状态和文件路径）
		fileStatusDAO.updateDataErrorFileStatus(map);
	}

	/**
	 * get the REGX template from database
	 * 
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	private String getRegxTplContent(Map<String, String> variableMap) throws Exception {
		FileServiceInfoEntity fileServiceInfoEntity = new FileServiceInfoEntity();
		String regxTplContent = null;
		String serviceID = variableMap.get(FileHandleConstant.FILE_SERVICE_ID);

		if (this.fileServiceInfoEntityMap.containsKey(serviceID)) {
			fileServiceInfoEntity = fileServiceInfoEntityMap.get(serviceID);
			regxTplContent = fileServiceInfoEntity.getFILE_REGX_TPL();
			return regxTplContent;
		}

		try {
			fileServiceInfoEntity = fileServiceInfoDAO.getRegxTplContent(variableMap);
			this.fileServiceInfoEntityMap.put(serviceID, fileServiceInfoEntity);
			regxTplContent = fileServiceInfoEntity.getFILE_REGX_TPL();
		} catch (Exception e) {
			String msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " error file;Exception happend while getting the REGX template from database..." + "("
					+ "从数据库获取校验模板异常..." + ")";
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);
			throw e;
		}

		return regxTplContent;
	}
}
