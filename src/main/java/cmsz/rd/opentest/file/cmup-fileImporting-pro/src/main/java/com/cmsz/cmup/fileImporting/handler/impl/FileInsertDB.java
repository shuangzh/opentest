package com.cmsz.cmup.fileImporting.handler.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.StringWriter;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import javax.annotation.Resource;

import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader;
import org.apache.velocity.tools.generic.NumberTool;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.alibaba.dubbo.remoting.TimeoutException;
import com.cmsz.cmup.commons.jdbc.service.JdbcService;
import com.cmsz.cmup.commons.logging.alarm.AlarmLogHandler;
import com.cmsz.cmup.commons.logging.mapper.AlarmLogBeanMapper;
import com.cmsz.cmup.commons.logging.system.SystemLogHandler;
import com.cmsz.cmup.commons.utils.FileLinesDataUtil;
import com.cmsz.cmup.fileImporting.constant.FileHandleConstant;
import com.cmsz.cmup.fileImporting.dao.FileServiceInfoDAO;
import com.cmsz.cmup.fileImporting.dao.FileStatusDAO;
import com.cmsz.cmup.fileImporting.entity.FileServiceInfoEntity;
import com.cmsz.cmup.fileImporting.handler.Handler;
import com.cmsz.cmup.fileImporting.validator.ValidateException;
import com.mchange.v2.c3p0.ComboPooledDataSource;

/**
 * 文件数据入库处理类
 * 
 * @author louiszhang
 * @time 20162016年4月20日下午4:35:27
 */
@Component
public class FileInsertDB implements Handler {

	private static AlarmLogHandler alarmLogger = AlarmLogHandler.getLogger(FileInsertDB.class);
	private static SystemLogHandler systemLogger = SystemLogHandler.getLogger(FileInsertDB.class);

	@Value("${dataSeparator}")
	String dataSeparator;
	@Value("${batchInsertDBValue}")
	int batchInsertDBValue;
	@Value("${insertDBThreadPoolSize}")
	int insertDBThreadPoolSize;
	@Value("${insertDBThreadTimeOut}")
	int insertDBThreadTimeOut;
	@Resource
	JdbcService jdbcService;
	@Resource
	FileLinesDataUtil fileLinesDataUtil;
	@Resource
	FileStatusDAO fileStatusDAO;
	@Resource
	FileServiceInfoDAO fileServiceInfoDAO;
	@Resource
	AlarmLogBeanMapper alarmLogBeanMapper;
	@Resource
	ComboPooledDataSource dataSource;
	@Resource
	FileValidator fileValidator;

	private Map<String, FileServiceInfoEntity> fileServiceInfoEntityMap = new HashMap<>();

	private VelocityEngine ve;
	private int veInitFlag = 0;

	@Override
	public Map<String, String> handle(Map<String, String> variableMap) throws Exception {
		String msgContext;
		BufferedReader reader;
		File file;

		// 初始化velocity（初始化一次状态位改为1，避免多次初始化）
		if (veInitFlag != 1) {
			veInit();
		}

		msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
				+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
				+ " file;Start to store the file's data into database..." + "(" + "文件开始入库..." + ")";
		systemLogger.info(msgContext, variableMap);

		// 初始化velocity模板
		try {
			variableMap = initVeloTpl(variableMap);
		} catch (Exception e) {
			msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while initializing the velocity template..." + "("
					+ "文件velocity模板初始化异常..." + ")";
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);
			fileStatusDAO.updateArrivedFileStatus(variableMap);
			throw e;
		}

		// 获取工作文件
		try {
			file = new File(variableMap.get(FileHandleConstant.LOCAL_FILE_PATH));
			reader = new BufferedReader(new FileReader(file));
		} catch (Exception e) {
			msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while dealing with the file in work folder, failed to store file data, please try again later..."
					+ "(" + "文件获取异常，入库失败，请稍后重试..." + ")";
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);
			fileStatusDAO.updateArrivedFileStatus(variableMap);
			throw e;
		}

		String dataLine;
		// 是否有文件头（文件头不入库，跳过）
		if (FileHandleConstant.FILE_HEADER_POSSESS.equals(variableMap.get(FileHandleConstant.FILE_HEADER))) {
			dataLine = reader.readLine();
		} else {
			dataLine = null;
		}

		// 获得文件尾
		String endLine;
		if (FileHandleConstant.FILE_ENDLINE_FINAL.equals(variableMap.get(FileHandleConstant.FILE_ENDLINE))) {
			// 文件尾为文件最后一行
			endLine = fileLinesDataUtil.getFinalLineData(variableMap);
		} else if (FileHandleConstant.FILE_ENDLINE_PENULTIMATE
				.equals(variableMap.get(FileHandleConstant.FILE_ENDLINE))) {
			// 文件尾为文件倒数第二行（即带签名文件）
			endLine = fileLinesDataUtil.getPenultimateData(variableMap);
		} else {
			// 无文件尾
			endLine = "NONE";
		}

		// 多线程入库线程池
		ExecutorService executorService = Executors.newFixedThreadPool(insertDBThreadPoolSize);

		// 文件数据数组list
		List<String[]> datasList = new ArrayList<>();

		// 线程结果存储表
		List<Future<String>> resultList = new ArrayList<>();
		dataLine = reader.readLine();
		try {
			while (!(dataLine == null || endLine.equals(dataLine))) {
				String[] datas = getDatas(dataLine, variableMap);

				datasList.add(datas);
				dataLine = reader.readLine();

				// 批量入库，入库阈值可配
				if (datasList.size() == batchInsertDBValue) {
					List<String[]> list = new ArrayList<>();
					list.addAll(datasList);
					resultList = threadPoolInsertDB(list, executorService, resultList, variableMap);

					// 清空sqlList
					datasList.clear();
				}
			}

			// 最后执行一次入库，避免sqllist有不足阈值条数语句没入库
			resultList = threadPoolInsertDB(datasList, executorService, resultList, variableMap);
		} catch (Exception e) {
			insertDBErrHandle(e, variableMap);
			// 删除工作文件
			file.delete();
			throw e;
		} finally {
			// 文件流关闭，
			reader.close();
		}

		// 检查多线程入库结果
		String result = "";
		try {
			for (Future<String> future : resultList) {
				result = future.get(insertDBThreadTimeOut, TimeUnit.SECONDS);

				String[] ss = result.split(":");
				if (!("sucess".equals(ss[1]))) {
					throw new InterruptedException();
				}
			}
		} catch (Exception e) {
			insertDBErrHandle(e, variableMap);
			throw e;
		} finally {
			// 删除工作文件
			file.delete();
			resultList.clear();

			// 出现异常，强制停止所有已经提交的任务，正在执行的也会尝试停止
			executorService.shutdownNow();
		}

		msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
				+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
				+ " file;Successful to store the file's data into database, finished handling this file..." + "("
				+ "文件成功入库，该文件处理流程结束..." + ")";
		systemLogger.info(msgContext, variableMap);

		return null;
	}

	/**
	 * 初始化velocity模板
	 * 
	 * @throws VelocityException
	 */
	public void veInit() throws VelocityException {
		VelocityEngine vEngine = new VelocityEngine();
		vEngine.setProperty(RuntimeConstants.RESOURCE_LOADER, "classpath");
		vEngine.setProperty("classpath.resource.loader.class", ClasspathResourceLoader.class.getName());
		vEngine.setProperty("runtime.log.logsystem.class", "org.apache.velocity.runtime.log.SimpleLog4JLogSystem");
		vEngine.setProperty("runtime.log.logsystem.log4j.category", "velocity");
		vEngine.setProperty("runtime.log.logsystem.log4j.logger", "velocity");
		vEngine.setProperty("runtime.log.error.stacktrace", false);
		vEngine.setProperty("runtime.log.warn.stacktrace", false);
		vEngine.setProperty("runtime.log.info.stacktrace", false);
		vEngine.init();

		this.veInitFlag = 1;
		this.ve = vEngine;
	}

	/**
	 * 批量入库，手动建立连接，关闭自动提交
	 * 
	 * @param list
	 * @param conn
	 * @param variableMap
	 * @throws Exception
	 */
	public void insert(List<String[]> list, Connection conn, Map<String, String> variableMap) throws Exception {
		PreparedStatement prest = null;

		String prstSql = variableMap.get("prestSql");

		try {
			conn.setAutoCommit(false);
			prest = conn.prepareStatement(prstSql);
		} catch (Exception e) {
			String msgContext = "Exception happend while connecting to database..." + "(" + "创建数据库连接异常..." + ")";
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);

			if (null != prest) {
				prest.close();
			}
			throw e;
		}

		// 循环遍历数据字段数组表，将字段数据放入入库语句
		for (String[] strings : list) {
			int i = 0;

			for (String string : strings) {
				i++;

				// 处理字段为null情况
				if (string == null) {
					string = "";
				}

				prest.setString(i, string);
			}

			// 一行数据处理完加入缓存
			prest.addBatch();
		}

		try {
			prest.executeBatch();
			conn.commit();
		} catch (Exception e) {
			throw e;
		} finally {
			prest.close();
		}
	}

	/**
	 * 多线程入库方法
	 * 
	 * @param datasList
	 * @param executorService
	 * @param resultList
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	private List<Future<String>> threadPoolInsertDB(List<String[]> datasList, ExecutorService executorService,
			List<Future<String>> resultList, Map<String, String> variableMap) throws Exception {

		Future<String> future = executorService.submit(new Tasks(datasList, variableMap));

		// task result save into List
		resultList.add(future);

		return resultList;
	}

	/**
	 * 内部多线程callable类
	 * 
	 * @author lenovo
	 *
	 */
	class Tasks implements Callable<String> {
		private List<String[]> newList;
		private Map<String, String> variableMap;

		public Tasks(List<String[]> list, Map<String, String> variableMap) {
			super();
			this.newList = list;
			this.variableMap = variableMap;
		}

		public String call() throws Exception {
			// 获取数据库连接
			Connection connection = dataSource.getConnection();

			try {
				insert(this.newList, connection, variableMap);
				return "Task" + Thread.currentThread().getId() + ":sucess";
			} catch (Exception e) {
				throw e;
			} finally {
				// 清空sqlList
				this.newList.clear();
				connection.close();
			}
		}
	}

	/**
	 * 文件入库错误处理
	 * 
	 * @param e
	 * @param variableMap
	 * @throws Exception
	 */
	private void insertDBErrHandle(Exception e, Map<String, String> variableMap) throws Exception {

		String msgContext = "";
		if (e.getMessage().indexOf(FileHandleConstant.UNIQUE_CONSTRAINT_VIOLATION_CODE) > 0) {
			msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while storing the file data into database, there is repeated data found, violated the unique constraint..."
					+ "(" + "文件入库异常，数据重复，违反唯一约束..." + ")";
			ValidateException vException = new ValidateException(null, ValidateException.CODE_REPEATDATA, msgContext);
			vException.append(vException);
			// 数据重复，进行错误文件处理流程
			fileValidator.errorFileHandler(variableMap, vException);
		} else if (e instanceof TimeoutException) {
			msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while storing the file data into database, time out for thread waiting, please try again later..."
					+ "(" + "文件入库异常，线程等待超时，请稍后重试..." + ")";
			fileStatusDAO.updateArrivedFileStatus(variableMap);
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);
		} else {
			msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while storing the file data into database, please try again later..."
					+ "(" + "文件入库异常，入库失败，请稍后重试..." + ")";
			fileStatusDAO.updateArrivedFileStatus(variableMap);
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);
		}
	}

	/**
	 * dealing with the different type of data rows
	 * 
	 * @param dataRow
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	private String[] getDatas(String dataRow, Map<String, String> variableMap) throws Exception {

		try {
			String mode = variableMap.get(FileHandleConstant.INSERT_MODE);
			if (mode.matches("^fix.*$")) {
				return getFixDatas(dataRow, variableMap, mode);
			} else {
				return dataRow.split(dataSeparator, -1);
			}
		} catch (Exception e) {
			throw e;
		}
	}

	/**
	 * get the data for the "fix" type data rows
	 * 
	 * @param dataRow
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	private String[] getFixDatas(String dataRow, Map<String, String> variableMap, String mode) throws Exception {

		String[] locations;
		try {
			locations = variableMap.get("location").trim().split("\\|");
		} catch (Exception e) {
			String msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " file;Exception happend while verifying the location info in the velocity template, please check the template file ..."
					+ "(" + "文件velocity模板中字段截取位置信息获取异常，请检查模板文件..." + ")";
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);
			fileStatusDAO.updateArrivedFileStatus(variableMap);
			throw e;
		}

		List<String> datas = new ArrayList<>();
		for (String string : locations) {
			String[] loc = string.split(",");
			int begin = Integer.parseInt(loc[0]);
			int end = Integer.parseInt(loc[1]);
			String oriValue = dataRow.substring(begin, end);

			// 首先将字段内容中补空格去除
			String value = null;
			if ("fix|rightBlank".equals(mode)) {
				// 去除右补空格
				value = oriValue.substring(0,
						oriValue.indexOf(oriValue.trim().substring(0, 1)) + oriValue.trim().length());
			} else if ("fix|leftBlank".equals(mode)) {
				// 去除左补空格
				value = oriValue.substring(oriValue.lastIndexOf(oriValue.trim()));
			} else {
				value = oriValue;
			}
			datas.add(value);
		}

		return (String[]) datas.toArray(new String[datas.size()]);
	}

	/**
	 * initializing the velocity template
	 * 
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	private Map<String, String> initVeloTpl(Map<String, String> variableMap) throws Exception {

		String insertDBTplContentString;
		try {
			insertDBTplContentString = getInsertDBTplContent(variableMap);
		} catch (Exception e) {
			throw e;
		}

		VelocityContext context = new VelocityContext();
		context.put("province", variableMap.get("province"));
		context.put("merchantType", variableMap.get(FileHandleConstant.FILE_MERCHANT));
		context.put("settleDate", variableMap.get("settleDate"));
		context.put("numberTool", new NumberTool());
		// 把参数map放入velo上下文进行渲染，在velo模板中可以直接取参数map中的值，用法：$!variableMap.get("XXXX")
		context.put("variableMap", variableMap);

		StringWriter sWriter = new StringWriter();
		this.ve.evaluate(context, sWriter, "", insertDBTplContentString);
		String veloString = sWriter.toString();

		String[] result = veloString.split("~");

		variableMap.put("prestSql", result[0].trim());

		if (result.length > 1) {
			variableMap.put("location", result[result.length - 1]);
		}

		return variableMap;
	}

	/**
	 * get the INSERTDB template from database
	 * 
	 * @param variableMap
	 * @return
	 * @throws Exception
	 */
	private String getInsertDBTplContent(Map<String, String> variableMap) throws Exception {
		FileServiceInfoEntity fileServiceInfoEntity = new FileServiceInfoEntity();
		String insertDBTplContent = null;
		String serviceID = variableMap.get(FileHandleConstant.FILE_SERVICE_ID);

		if (this.fileServiceInfoEntityMap.containsKey(serviceID)) {
			fileServiceInfoEntity = fileServiceInfoEntityMap.get(serviceID);
			insertDBTplContent = fileServiceInfoEntity.getFILE_INSERTDB_TPL();
			return insertDBTplContent;
		}

		try {
			fileServiceInfoEntity = fileServiceInfoDAO.getInsertDBTplContent(variableMap);
			this.fileServiceInfoEntityMap.put(serviceID, fileServiceInfoEntity);
			insertDBTplContent = fileServiceInfoEntity.getFILE_INSERTDB_TPL();
		} catch (Exception e) {
			String msgContext = variableMap.get(FileHandleConstant.FILE_NAME) + ";"
					+ variableMap.get(FileHandleConstant.FILE_TYPE_DESC)
					+ " error file;Exception happend while getting the INSERTDB template from database..." + "("
					+ "从数据库获取校验模板异常..." + ")";
			alarmLogger.error(msgContext, variableMap, e);
			systemLogger.error(msgContext, variableMap, e);
			throw e;
		}

		return insertDBTplContent;
	}
}
