package cmsz.rd.opentest.file.validator.impl.fieldMatcher;

import cmsz.rd.opentest.file.validator.Field;
import cmsz.rd.opentest.file.validator.FieldMatcher;
import cmsz.rd.opentest.file.validator.ValidateException;
import cmsz.rd.opentest.file.validator.templateCfg.CaseCfg;
import cmsz.rd.opentest.file.validator.templateCfg.FactorCfg;
import cmsz.rd.opentest.file.validator.templateCfg.FieldCfg;
import cmsz.rd.opentest.file.validator.templateCfg.OperatorCfg;
import cmsz.rd.opentest.utils.DateUtil;

import java.math.BigDecimal;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * the default field matcher which contains functions like logical validation
 * and validating field that is comparable with the input parameter etc.These
 * founctions can be configured in the validation XML template files.
 * 
 * @author louiszhang
 * @time 20162016年4月20日下午4:42:40
 */
public class DefaultFieldMatcherImpl implements FieldMatcher {

	private Map<String, String> map = new HashMap<>();
	private Map<String, String> uniqueMap = new HashMap<>();
	private Map<String, List<CaseCfg>> relaMap = new HashMap<>();
	private List<OperatorCfg> operators = new ArrayList<>();
	private Map<String, Field> opRelaFields = new HashMap<>();
	private Map<String, Field> conditionFields = new HashMap<>();

	public ValidateException match(int lineNum, Field field, String mode) throws Exception {
		ValidateException vException = null;
		String errmsg = null;

		if (mode.matches("^fix.*$")) {
			// 首先将字段内容中补空格去除
			String oriValue = field.getValue();
			String value = getStringDeletedSideBlank(oriValue, mode);
			field.setValue(value);
		}

		// 初始化运算器参与字段Map
		initOpRelaFields(field);

		if (field.getPassParam() != null && "yes".equals(field.getPassParam())) {
			// 校验字段与对应传入参数相同情况
			if (!(map.get(field.getName()).equals(field.getValue()))) {
				errmsg = ";" + lineNum + " line's " + field.getName()
						+ " field;Failed for the field validation, the details are : ";
				vException = new ValidateException(null, null, errmsg + field.toString());
			}
		} else if (field.getFixValue() != null && field.getFixValue().length() > 0) {
			// 校验字段为固定字符情况
			if (!(field.getFixValue().equals(field.getValue()))) {
				errmsg = ";" + lineNum + " line's " + field.getName()
						+ " field;Failed for the field validation, the details are : ";
				vException = new ValidateException(null, null, errmsg + field.toString());
			}
		} else {
			// 通用匹配正则表达的校验
			if (!field.getValue().matches(field.getRegx())) {
				errmsg = ";" + lineNum + " line's " + field.getName()
						+ " field;Failed for the field validation, the details are : ";
				vException = new ValidateException(null, null, errmsg + field.toString());
			}
		}
		// 判断此时是否有校验不通过发生，若此时已经出现校验不通过现象，则返回结果，结束校验，此时已不需要再继续校验
		if (vException != null) {
			return vException;
		}

		// 校验字段又包含其他组成部分需要单独校验的情况
		if (field.getComponent() != null) {
			return vException = matchComponent(lineNum, field);
		}

		// 校验有特定情景的field
		if (field.getCases() != null && field.getCases().size() > 0) {
			if (!(field.getRelated() != null && "yes".equals(field.getRelated()))) {
				vException = matchNoRelatedCases(lineNum, field);
				return vException;
			}
		}

		// 逻辑校验处理
		if (field.getRelated() != null && "yes".equals(field.getRelated())) {
			vException = matchRelatedFields(lineNum, field);
			return vException;
		}

		// 唯一性校验处理
		if (field.getUnique() != null && "yes".equals(field.getUnique())) {
			String key = field.getName() + field.getValue();
			if (uniqueMap.containsKey(key)) {
				errmsg = ";" + lineNum + " line's " + field.getName() + " field is repeated with " + uniqueMap.get(key)
						+ " line's, failed for the field validation...";
				vException = new ValidateException(null, ValidateException.CODE_REPEATDATA, errmsg);
				return vException;
			} else {
				uniqueMap.put(key, lineNum + "");
			}
		}

		// 逻辑校验：字段间运算关系校验
		if ("yes".equals(field.getIsFinalField())) {
			try {
				vException = checkOprations(lineNum, mode);
			} catch (Exception e) {
				throw e;
			}
		}

		return vException;
	}

	/**
	 * 字段校验含有其他组成部分的域校验器
	 * 
	 * @param lineNum
	 * @param cfg
	 * @param field
	 * @return
	 * @throws Exception
	 */
	private ValidateException matchComponent(int lineNum, Field field) throws Exception {
		ValidateException vException = null;
		List<FieldCfg> fields = new ArrayList<>();
		fields = field.getComponent().getCompFields();

		for (FieldCfg f : fields) {
			f.setValue(field.getValue().substring(f.getBegin(), f.getEnd()));
			vException = this.match(lineNum, transFiledCfgToField(f), "");

			if (vException != null) {
				vException.append(vException);
			}
		}

		return vException;
	}

	/**
	 * 逻辑校验器(需在参与逻辑校验的第一个字段上配置逻辑规则)
	 * 
	 * @param lineNum
	 * @param field
	 * @return
	 * @throws Exception
	 */
	private ValidateException matchRelatedFields(int lineNum, Field field) throws Exception {
		ValidateException vException = null;
		List<CaseCfg> cases = new ArrayList<>();

		if (relaMap.containsKey(field.getName())) {
			// 逻辑校验情景存储map中存有此field的逻辑校验情景，则说明此field需要进行逻辑校验
			cases = relaMap.get(field.getName());
			// 与此field相关的逻辑校验情景都要通过才说明与此field相关的逻辑校验都通过了
			String errmsg = "";
			for (CaseCfg caseCfg : cases) {
				// 必须是同一条记录才做逻辑校验
				if (lineNum == caseCfg.getLineNo()) {
					Field f = (Field) caseCfg.getRelaField();
					f.setValue(field.getValue());
					vException = this.match(lineNum, f, "");
				}

				if (vException != null) {
					errmsg += caseCfg.getMassage() + vException.getErrmsg();
				}
			}

			if (errmsg.length() > 0) {
				vException = new ValidateException(null, null, errmsg);
			}
		} else {
			// 逻辑校验情景存储map中无此field的逻辑校验情景，则说明此field与其他field有逻辑校验情景，此时将这些逻辑校验情景存入map
			if (field.getCases() != null && field.getCases().size() > 0) {
				for (CaseCfg caseCfg : field.getCases()) {
					// 当前字段满足逻辑校验触发条件正则表达式的才会正式处理此case，不满足逻辑校验触发条件无需保存此逻辑校验场景
					if (field.getValue().matches(caseCfg.getRegx())) {
						// map中key为参与逻辑校验的field名称，这样可以将某field参与的所有逻辑校验全部存入其名下的list
						String key = caseCfg.getRelaField().getName();
						List<CaseCfg> vCfgs = relaMap.get(key);
						if (vCfgs == null) {
							vCfgs = new ArrayList<>();
						}

						// 如果此逻辑校验情景为参与逻辑校验的另一方field与此field数值要相等，则将参与逻辑校验的另一方field的固定值设为此field的值
						if (caseCfg.getIsEqual() != null && "yes".equals(caseCfg.getIsEqual())) {
							caseCfg.getRelaField().setFixValue(field.getValue());
						}

						String massage = ";Logical validation;While fieldName=" + field.getName() + " and value="
								+ field.getValue() + ", then " + caseCfg.getRelaField().toString();
						caseCfg.setMassage(massage);
						caseCfg.setLineNo(lineNum);
						vCfgs.add(caseCfg);

						relaMap.put(key, vCfgs);
					}
				}
			}
		}

		return vException;
	}

	/**
	 * 校验某field非逻辑校验的特定场景
	 * 
	 * @param lineNum
	 * @param field
	 * @return
	 * @throws Exception
	 */
	private ValidateException matchNoRelatedCases(int lineNum, Field field) throws Exception {
		ValidateException vException = null;
		List<CaseCfg> caseCfgs = field.getCases();

		boolean b = false;
		for (CaseCfg caseCfg : caseCfgs) {
			Field f = (Field) caseCfg.getRelaField();
			f.setValue(field.getValue());
			vException = this.match(lineNum, f, "");
			if (vException == null) {
				b = true;
			}
		}

		if (b) {
			return null;
		} else {
			String errmsg = caseCfgs.get(0).getMassage() + ";" + lineNum + " line's " + field.getName()
					+ " filed;Failed for the field validation, the details are : ";
			vException = new ValidateException(null, null, errmsg + field.toString());
		}

		return vException;
	}

	/**
	 * get the result string that get it's blank spaces on the right or left
	 * side deleted
	 * 
	 * @param oriValue
	 * @return
	 */
	private String getStringDeletedSideBlank(String oriValue, String mode) {
		String value = null;

		// 字段内容全为空格则直接返回空字符串
		if (0 == oriValue.trim().length()) {
			return "";
		}

		if ("fix|rightBlank".equals(mode)) {
			// 去除右补空格
			int end = oriValue.indexOf(oriValue.trim().substring(0, 1)) + oriValue.trim().length();
			value = oriValue.substring(0, end);
		} else if ("fix|leftBlank".equals(mode)) {
			// 去除左补空格
			value = oriValue.substring(oriValue.lastIndexOf(oriValue.trim()));
		} else {
			return oriValue;
		}

		return value;
	}

	public Map<String, String> getMap() {
		return map;
	}

	public void setMap(Map<String, String> map) {
		this.map = map;
	}

	/**
	 * 初始化运算器参与字段Map
	 * 
	 * @author louiszhang
	 * @time 20162016年8月16日下午4:40:13
	 * @param field
	 */
	private void initOpRelaFields(Field field) {

		if (null == operators || operators.isEmpty()) {
			return;
		}

		for (OperatorCfg operatorCfg : operators) {
			String resultField = operatorCfg.getResult();
			if (resultField.equals(field.getName())) {
				opRelaFields.put(field.getName(), field);
			}

			// 逻辑运算参与域初始化
			List<FactorCfg> factorCfgs = operatorCfg.getFactors();
			for (FactorCfg factorCfg : factorCfgs) {
				String factorName = factorCfg.getFactorName();
				if (field.getName().equals(factorName)) {
					opRelaFields.put(field.getName(), field);
				}
			}

			// 触发条件域初始化
			List<FieldCfg> conditions = operatorCfg.getConditions();
			if (conditions != null && conditions.size() > 0) {
				for (FieldCfg fieldCfg : conditions) {
					String conFieldName = fieldCfg.getName();
					if (conFieldName.equals(field.getName())) {
						Field f = this.transFiledCfgToField(fieldCfg);
						f.setValue(field.getValue());
						conditionFields.put(field.getName(), f);
					}
				}
			}

		}
	}

	/**
	 * 运算器运算处理方法
	 * 
	 * @author louiszhang
	 * @time 20162016年8月17日下午2:21:46
	 * @param lineNum
	 * @return
	 * @throws ParseException
	 * @throws Exception
	 */
	private ValidateException checkOprations(int lineNum, String mode) throws Exception {

		if (null == operators || operators.isEmpty()) {
			return null;
		}

		ValidateException vException = null;

		for (OperatorCfg operatorCfg : operators) {
			// 首先判断触发条件是否满足, 不满足条件跳过本次逻辑运算校验
			vException = this.checkConditions(operatorCfg, lineNum, mode);
			if (vException != null) {
				vException = null;
				continue;
			}

			String oprator = operatorCfg.getOperator();
			switch (oprator) {
			case "add":
				return oprationAdd(operatorCfg, lineNum);

			case "multi":
				return oprationMulti(operatorCfg, lineNum);

			case "lessThan":
				return oprationLessThan(operatorCfg, lineNum);
			}
		}

		return vException;
	}

	// 检查逻辑运算条件是否满足
	private ValidateException checkConditions(OperatorCfg operatorCfg, int lineNum, String mode) throws Exception {
		ValidateException vException = null;
		String mString = "";

		List<FieldCfg> conditions = operatorCfg.getConditions();
		// 无触发条件直接返回
		if (conditions == null || conditions.size() == 0) {
			return null;
		}

		for (FieldCfg fieldCfg : conditions) {
			if (!this.conditionFields.containsKey(fieldCfg.getName())) {
				mString = "异常！逻辑运算校验未找到必须的触发条件域：" + fieldCfg.toString() + "；请检查。";
				throw (new ValidateException(null, null, mString));
			}

			Field field = conditionFields.get(fieldCfg.getName());
			vException = this.match(lineNum, field, mode);
		}

		return vException;
	}

	/**
	 * 求和校验处理方法
	 * 
	 * @author louiszhang
	 * @time 20162016年8月16日下午5:33:04
	 * @param operatorCfg
	 * @return
	 */
	private ValidateException oprationAdd(OperatorCfg operatorCfg, int lineNum) {
		String mString = "";
		ValidateException veException = null;

		String resultName = operatorCfg.getResult();
		if (!this.opRelaFields.containsKey(resultName)) {
			mString = ";文件第" + lineNum + "行；多字段间验证求和结果运算校验时不通过，未找到需要参与求和校验的字段: " + resultName + "，请检查。"
					+ operatorCfg.toString();
			veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
			return veException;
		}
		String resultValue = this.opRelaFields.get(resultName).getValue().trim();
		if (null == resultValue || resultValue.length() == 0) {
			resultValue = "0";
		}
		BigDecimal result = new BigDecimal(resultValue);

		BigDecimal factorSum = new BigDecimal("0");
		for (FactorCfg factor : operatorCfg.getFactors()) {
			String factorName = factor.getFactorName();
			if (!this.opRelaFields.containsKey(factorName)) {
				mString = ";文件第" + lineNum + "行；多字段间验证求和结果运算校验时不通过，未找到需要参与求和校验的字段: " + factorName + "，请检查。"
						+ operatorCfg.toString();
				veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
				return veException;
			}
			String factorValue = this.opRelaFields.get(factorName).getValue().trim();
			if (null == factorValue || factorValue.length() == 0) {
				factorValue = "0";
			}
			factorSum = factorSum.add(new BigDecimal(factorValue));
		}

		if (0 != result.compareTo(factorSum)) {
			mString = ";文件第" + lineNum + "行；多字段间验证求和结果运算校验时不通过，求出结果不满足公式，请检查。" + operatorCfg.toString() + "实际上："
					+ resultValue + "!=" + factorSum.toString();
			;
			veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
		}

		return veException;
	}

	/**
	 * 求积校验处理方法
	 * 
	 * @author louiszhang
	 * @time 20162016年8月16日下午5:37:07
	 * @param operatorCfg
	 * @return
	 */
	private ValidateException oprationMulti(OperatorCfg operatorCfg, int lineNum) {
		String mString = "";
		ValidateException veException = null;

		String resultName = operatorCfg.getResult();
		if (!this.opRelaFields.containsKey(resultName)) {
			mString = ";文件第" + lineNum + "行；多字段间验证求积结果运算校验时不通过，未找到需要参与求积校验的字段: " + resultName + "，请检查。"
					+ operatorCfg.toString();
			veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
			return veException;
		}
		String resultValue = this.opRelaFields.get(resultName).getValue().trim();
		if (null == resultValue || resultValue.length() == 0) {
			resultValue = "0";
		}
		BigDecimal result = new BigDecimal(resultValue);

		BigDecimal factorSum = new BigDecimal("1");
		for (FactorCfg factor : operatorCfg.getFactors()) {
			String factorName = factor.getFactorName();
			if (!this.opRelaFields.containsKey(factorName)) {
				mString = ";文件第" + lineNum + "行；多字段间验证求积结果运算校验时不通过，未找到需要参与求积校验的字段: " + factorName + "，请检查。"
						+ operatorCfg.toString();
				veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
				return veException;
			}
			String factorValue = this.opRelaFields.get(factorName).getValue().trim();
			if (null == factorValue || factorValue.length() == 0) {
				factorValue = "0";
			}
			factorSum = factorSum.multiply(new BigDecimal(factorValue));
		}

		if (0 != result.compareTo(factorSum)) {
			mString = ";文件第" + lineNum + "行；多字段间验证求积结果运算校验时不通过，求出结果不满足公式，请检查。" + operatorCfg.toString() + "实际上："
					+ resultValue + "!=" + factorSum.toString();
			veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
		}

		return veException;
	}

	/**
	 * 小于校验处理方法
	 * 
	 * @author lenovo
	 * @time 20162016年12月8日下午3:16:53
	 * @param operatorCfg
	 * @param lineNum
	 * @return
	 * @throws ParseException
	 */
	private ValidateException oprationLessThan(OperatorCfg operatorCfg, int lineNum) throws ParseException {
		String mString = "";
		ValidateException veException = null;

		String resultName = operatorCfg.getResult();
		if (!this.opRelaFields.containsKey(resultName)) {
			mString = ";文件第" + lineNum + "行；多字段间验证小于运算校验时不通过，未找到需要参与小于校验的字段: " + resultName + "，请检查。"
					+ operatorCfg.toString();
			veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
			return veException;
		}
		String resultValue = this.opRelaFields.get(resultName).getValue().trim();
		if (null == resultValue || resultValue.length() == 0) {
			resultValue = "0";
		}
		BigDecimal result = new BigDecimal(resultValue);

		for (FactorCfg factor : operatorCfg.getFactors()) {
			String factorName = factor.getFactorName();
			if (!this.opRelaFields.containsKey(factorName)) {
				mString = ";文件第" + lineNum + "行；多字段间验证小于运算校验时不通过，未找到需要参与小于校验的字段: " + factorName + "，请检查。"
						+ operatorCfg.toString();
				veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
				return veException;
			}
			String factorValue = this.opRelaFields.get(factorName).getValue().trim();
			if (null == factorValue || factorValue.length() == 0) {
				factorValue = "0";
			}

			// 获得小于比较的范围值
			String lessThanValueString = factor.getLessThanValue().trim();
			BigDecimal lessThanValue;
			if (null == lessThanValueString || lessThanValueString.length() == 0) {
				lessThanValue = new BigDecimal("0");
				lessThanValueString = "";
			} else {
				lessThanValue = new BigDecimal(lessThanValueString);
			}

			boolean b = true;
			BigDecimal factorValueBigDemi = null;
			if ("yes".equals(operatorCfg.getIsTime())) {
				b = checkTimeLessThan(resultValue, factorValue, lessThanValueString);
			} else {
				factorValueBigDemi = new BigDecimal(factorValue);
				b = checkNumLessThan(result, factorValueBigDemi, lessThanValue);
			}

			if (!b) {
				mString = ";文件第" + lineNum + "行；多字段间验证小于运算校验时不通过，比较结果不满足公式，请检查。" + operatorCfg.toString() + "实际上："
						+ resultValue + "不比" + factorValueBigDemi.toString() + "小" + lessThanValueString;
				veException = new ValidateException(null, ValidateException.CODE_FAILED, mString);
			}
		}
		return veException;
	}

	/**
	 * 检验时间差
	 * 
	 * @author lenovo
	 * @time 20162016年12月8日下午3:42:54
	 * @param oldDate
	 * @param newDate
	 * @param lessThanValue
	 * @return
	 * @throws ParseException
	 * @throws Exception
	 */
	private boolean checkTimeLessThan(String oldDate, String newDate, String lessThanValue) throws ParseException {

		boolean b = true;
		long subDate = DateUtil.getsubDate(newDate, oldDate);
		if (subDate < 0) {
            return false;
        }

		if (lessThanValue == null || lessThanValue.length() == 0) {
            // 不需要比较小于范围，只比较小于
            if (subDate == 0) {
                b = false;
            }
        } else {
            // 需要比较时间差在小于范围内
            long lessThanDateLong = Long.parseLong(lessThanValue);
            if (subDate > lessThanDateLong) {
                b = false;
            }
        }

		return b;
	}

	/**
	 * 检验数字差
	 * 
	 * @author lenovo
	 * @time 20162016年12月8日下午4:19:49
	 * @param biggerValue
	 * @param factorValue
	 * @param lessThanValue
	 * @return
	 */
	private boolean checkNumLessThan(BigDecimal biggerValue, BigDecimal factorValue, BigDecimal lessThanValue) {
		boolean b = true;

		factorValue.add(lessThanValue);
		if (-1 == factorValue.compareTo(biggerValue)) {
			b = false;
		}

		return b;
	}

	/**
	 * cast FiledCfg to Field
	 * 
	 * @author louiszhang
	 * @time 20162016年8月10日上午9:53:35
	 * @param fieldCfg
	 * @return
	 */
	private Field transFiledCfgToField(FieldCfg fieldCfg) {
		Field field = new Field();
		field.setName(fieldCfg.getName());
		field.setValue(fieldCfg.getValue());
		field.setRegx(fieldCfg.getRegx());
		field.setBegin(fieldCfg.getBegin());
		field.setEnd(fieldCfg.getEnd());
		field.setUnique(fieldCfg.getUnique());
		field.setRelated(fieldCfg.getRelated());
		field.setComponent(fieldCfg.getComponent());
		field.setPassParam(fieldCfg.getPassParam());
		field.setFixValue(fieldCfg.getFixValue());
		field.setCases(fieldCfg.getCases());
		field.setOperator(fieldCfg.getOperator());

		return field;
	}

	public List<OperatorCfg> getOperators() {
		return operators;
	}

	public void setOperators(List<OperatorCfg> operators) {
		this.operators = operators;
	}

	public Map<String, Field> getOpRelaFields() {
		return opRelaFields;
	}

	public void setOpRelaFields(Map<String, Field> opRelaFields) {
		this.opRelaFields = opRelaFields;
	}

	public Map<String, Field> getConditionFields() {
		return conditionFields;
	}

	public void setConditionFields(Map<String, Field> conditionFields) {
		this.conditionFields = conditionFields;
	}

}
