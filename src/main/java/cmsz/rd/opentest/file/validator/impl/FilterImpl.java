package cmsz.rd.opentest.file.validator.impl;


import cmsz.rd.opentest.file.validator.*;
import cmsz.rd.opentest.file.validator.templateCfg.OperatorCfg;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 校验处理类
 *
 * @author lenovo
 */
public class FilterImpl implements Filter {

    final public static String C_TYPE_SEP = "sep";
    final public static String C_TYPE_FIX = "^fix.*$";

    private String seperator; // 切分符号
    private String type; // 数据校验类型（1.sep，2.fix）
    private FieldMatcher fieldMatcher = null; // 校验器
    private String startWith; // 数据起始字符
    private int fixRowNum; // 检验固定行数
    private int fixLength; // 检验固定长度
    private List<Field> fieldList; // 数据域校验规则承载表
    private String errorCode;// 错误返回码

    private Section section; // 被校验数据信息承载类
    private String line; // 校验数据

    private List<OperatorCfg> operators;// 运算器列表s

    //zhoushuang : 由ValidatorImpl传给 FilterImpl,用于以List<map>形式存储文件数据
    private List<Map<String, String>> dataForList;

    public void setDataForList(List<Map<String, String>> dataForList) {
        this.dataForList = dataForList;
    }

    public void addDataForList() {
        Map<String, String> row = new HashMap<>();
        row.put("-ln", String.valueOf(section.getPosition()));
        for (Field f : this.fieldList) {
            // 字段名都转化为小写
            row.put(f.getName().toLowerCase(), f.getValue());
        }
        this.dataForList.add(row);
    }

    /**
     * 校验处理方法
     *
     * @throws Exception
     */
    public void doFilter(Section section, FilterChain filterChain) throws Exception {
        this.section = section;
        line = section.getContent();

        // 处理有起始字符校验的数据
        if (this.startWith != null && this.startWith.trim().length() > 0) {
            if (line.startsWith(this.startWith)) {

                // 校验是否为固定某一行（如文件头必须为文件第一行）
                if (this.fixRowNum != 0) {
                    if (this.fixRowNum > 0 && this.fixRowNum != section.getPosition()) {
                        // 不是filter所需固定行交给下一个filter
                        filterChain.doFilter(section);
                        return;
                    }
                }

                // 校验固定长度
                if (this.fixLength > 0 && this.fixLength != line.length()) {
                    String errmsg = ValidateException.EMSG_LENGTH + "; the length must be :" + this.fixLength + "("
                            + "行长度不正确，长度应为" + this.fixLength + "实际长度为" + line.length() + ").";
                    throw new ValidateException(this.section, ValidateException.CODE_LENGTH, errmsg);
                }

                // 判断校验类型
                if (this.type.compareTo(C_TYPE_SEP) == 0) {
                    if (1 == this.line.split(seperator).length) {
                        // 分隔符不符合继续寻找filter
                        filterChain.doFilter(section);
                        return;
                    }
                    this.doSep();
                } else if (this.type.matches(C_TYPE_FIX)) {
                    this.doFix();
                } else {
                    throw new ValidateException(this.section, ValidateException.CODE_NOTYPE,
                            ValidateException.EMSG_NOTYPE);
                }
            } else {
                // 没有匹配到起始字符自动交给下一个校验器
                filterChain.doFilter(section);
                return;
            }
        } else {
            // 处理没有起始字符校验的数据
            if (this.fixRowNum != 0) {
                if (this.fixRowNum > 0 && this.fixRowNum != section.getPosition()) {
                    filterChain.doFilter(section);
                    return;
                }
            }

            // 校验固定长度
            if (this.fixLength > 0 && this.fixLength != line.length()) {
                throw new ValidateException(this.section, ValidateException.CODE_LENGTH,
                        ValidateException.EMSG_LENGTH + "; the length must be :" + this.fixLength);
            }

            if (this.type.compareTo(C_TYPE_SEP) == 0) {
                if (1 == this.line.split(seperator).length) {
                    // 分隔符不符合继续寻找filter
                    filterChain.doFilter(section);
                    return;
                }
                this.doSep();
            } else if (this.type.matches(C_TYPE_FIX)) {
                this.doFix();
            } else {
                throw new ValidateException(this.section, ValidateException.CODE_NOTYPE, ValidateException.EMSG_NOTYPE);
            }
        }
    }

    /**
     * 校验需要按照规定切分符号切分出数据字段的情况
     *
     * @throws Exception
     */
    private void doSep() throws Exception {
        String[] fields = (this.section.getContent() + "|1").split(seperator);

        // 校验字段数量是否正确
        if ((fields.length - 1) != this.fieldList.size()) {
            throw new ValidateException(this.section, ValidateException.CODE_FIELDSUM, ValidateException.EMSG_FIELDSUM);
        }

        // 初始化域校验列表
        for (int i = 0; i < fieldList.size(); i++) {
            this.fieldList.get(i).setValue(fields[i]);
            this.fieldList.get(i)
                    .setDesc("第" + Integer.toString(i + 1) + "个字段(field No." + Integer.toString(i + 1) + ")");

            // 若为最后一个field，则将最后field标识isFinalField修改成yes
            if (i == (fieldList.size() - 1)) {
                this.fieldList.get(i).setIsFinalField("yes");
            }
        }

        //zhoushuang:解析字段后，存到dataForList中
        this.addDataForList();


        String errmsg = null;
        ValidateException vException = null;
        this.fieldMatcher.setOpRelaFields(new HashMap<String, Field>());

        // 遍历域校验表进行字段校验
        for (Field f : this.fieldList) {
            // 可以实现字段校验出错跳过逻辑表达式校验
            if (errmsg != null && "yes".equals(f.getIsFinalField())) {
                f.setIsFinalField("error");
            }

            vException = this.fieldMatcher.match(this.section.getPosition(), f, "sep");
            if (vException != null) {
                errmsg += vException.getErrmsg();

                // 如果错误类型为数据行重复，则更新为数据重复的错误返回码
                if (ValidateException.CODE_REPEATDATA.equals(vException.getCode())) {
                    setErrorCode(vException.getCode());
                }
            }
        }

        // errmsg不为空说明有校验不通过情况出现
        if (errmsg != null) {
            // 返回错误信息
            String emsg = getRealEmsg(errmsg);

            throw new ValidateException(this.section, this.errorCode, emsg);
        }
    }

    /**
     * 校验一行数据是固定长度且没有切分字段的情况
     *
     * @throws Exception
     */
    private void doFix() throws Exception {

        // 初始化域校验表
        int i = 1;
        for (Field f : this.fieldList) {
            f.setValue(line.substring(f.getBegin(), f.getEnd()));

            if (i == fieldList.size()) {
                f.setIsFinalField("yes");
            }
            i++;
        }

        // zhoushuang:解析字段后，存到dataForList中
        this.addDataForList();

        // 遍历域校验表进行字段校验
        String errmsg = null;
        ValidateException vException = null;
        this.fieldMatcher.setOpRelaFields(new HashMap<String, Field>());

        for (Field f : this.fieldList) {
            // 可以实现字段校验出错跳过逻辑表达式校验
            if (errmsg != null && "yes".equals(f.getIsFinalField())) {
                f.setIsFinalField("error");
            }

            try {
                vException = this.fieldMatcher.match(this.section.getPosition(), f, this.type);
            } catch (Exception e) {
                throw e;
            }
            if (vException != null) {
                errmsg += vException.getErrmsg();

                // 如果错误类型为数据行重复，则更新为数据重复的错误返回码
                if (ValidateException.CODE_REPEATDATA.equals(vException.getCode())) {
                    setErrorCode(vException.getCode());
                }
            }
        }

        // errmsg不为空说明有校验不通过情况出现
        if (errmsg != null) {
            // 返回错误信息
            String emsg = getRealEmsg(errmsg);

            throw new ValidateException(this.section, this.errorCode, emsg);
        }

    }

    /**
     * 获得最终错误信息
     *
     * @param errmsg
     * @return
     */
    private String getRealEmsg(String errmsg) {
        String emsg;

        // 根据数据不同位置（文件头、尾等区别）确定相应错误信息
        if (ValidateException.CODE_FILEHEADER.equals(this.errorCode)) {
            emsg = ValidateException.EMSG_CODE_FILEHEADER + errmsg;
        } else if (ValidateException.CODE_FILEEND.equals(this.errorCode)) {
            emsg = ValidateException.EMSG_CODE_FILEEND + errmsg;
        } else if (ValidateException.CODE_REPEATDATA.equals(this.errorCode)) {
            emsg = ValidateException.EMSG_CODE_REPEATDATA + errmsg;
        } else {
            emsg = ValidateException.EMSG_NOMATCH + errmsg;
        }

        return emsg;
    }

    public FieldMatcher getFieldMatcher() {
        return this.fieldMatcher;
    }

    public int getFixRowNum() {
        return this.fixRowNum;
    }

    public String getStartWith() {
        return this.startWith;
    }

    public int getFixLength() {
        return this.fixLength;
    }

    public String getSeperator() {
        return seperator;
    }

    public void setSeperator(String seperator) {
        this.seperator = seperator;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public List<Field> getFieldList() {
        return fieldList;
    }

    public void setFieldList(List<Field> fieldList) {
        this.fieldList = fieldList;
    }

    public void setFieldMatcher(FieldMatcher fieldMatcher) {
        this.fieldMatcher = fieldMatcher;
    }

    public void setStartWith(String startWith) {
        this.startWith = startWith;
    }

    public void setFixRowNum(int fixRowNum) {
        this.fixRowNum = fixRowNum;
    }

    public void setFixLength(int fixLength) {
        this.fixLength = fixLength;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public List<OperatorCfg> getOperators() {
        return operators;
    }

    public void setOperators(List<OperatorCfg> operators) {
        this.operators = operators;
    }

}
